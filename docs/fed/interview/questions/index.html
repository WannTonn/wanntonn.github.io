<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.110.0"><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=manifest href=/favicons/site.webmanifest><link rel="shortcut icon" href=/favicons/favicon.ico><title>前端面试题、知识点收集 - {...Life}</title><meta name=author content="WannTonn"><meta name=keywords content="Code"><meta property="og:title" content="前端面试题、知识点收集"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://blogs.wanntonn.fun/fed/interview/questions/"><meta property="og:image" content="https://blogs.wanntonn.fun/images/Code/javascript.png"><meta property="article:published_time" content="2023-01-30T23:35:24+08:00"><meta property="article:modified_time" content="2023-01-30T23:35:24+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blogs.wanntonn.fun/images/Code/javascript.png"><meta name=twitter:title content="前端面试题、知识点收集"><meta name=twitter:description content><link rel=stylesheet href=/assets/amzrk2.min.css><script></script><body data-theme=auto data-section=single><script>!function(e){let t;try{t=JSON.parse(localStorage.getItem("amzrk2-theme"))}catch{t=null}t&&t!==e&&document.body.setAttribute("data-theme",t)}(document.body.getAttribute("data-theme"))</script><div id=top style=height:0;overflow:hidden></div><header><nav class=navbar><div class=container><div class=navbar-brand><a class=navbar-item href=https://blogs.wanntonn.fun>{...Life}</a></div><div class=navbar-menu><div class=navbar-start><a class=navbar-item href=/post/>笔记</a>
<a class=navbar-item href=/fed/>前端</a>
<a class=navbar-item href=/hackintosh/>MacOS</a>
<a class=navbar-item href=/tags/>标签</a>
<a class=navbar-item href=/about/>关于</a></div><div class=navbar-end><div class=navbar-item id=ctrl-adjust><svg class="icon" aria-hidden="true"><use xlink:href="#icon-adjust"/></svg></div><a class=navbar-item id=ctrl-rss href=/index.xml target=_blank><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss"/></svg></a><div class=navbar-item id=ctrl-toc><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bars"/></svg></div></div></div></nav></header><main><div class="container single-container"><div class="columns single-columns"><div class="column single-content is-three-quarters"><div class=card><div class="post-image image-wrapper ratio-32x9"><img src=/images/Code/javascript.png></div><div class=post-box><h2 class=post-title>前端面试题、知识点收集</h2><div class=post-meta><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-day"/></svg>&nbsp;<time>2023-01-30</time></span>
<span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clock"/></svg>&nbsp;15 min</span>
<span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hashtag"/></svg>&nbsp;<a href=/tags/code>Code</a></span></div></div><div class=post-content><article class="markdown content"><ul><li><p>谈谈 Vue 和 React 这 2 个框架的理解与区别</p><ul><li>两个框架都提倡组件化，都是通过虚拟 DOM 高效实现更新视图。都使用了 diff 算法，也都对 diff 算法进行了优化。都有 router 库实现 URL 到组件的映射，都有状态管理等。</li><li>什么是组件化？<ul><li>组件是独立和可复用的代码组织单元，使开发者使用小型，独立和通常可复用的组件构建大型应用</li><li>组件化开发能大幅提高应用 开发效率，测试性，复用性</li><li>降低整个系统的耦合度，在保持接口不变的情况下，可以替换不同的组件快速完成需求。eg：输入框，日历，时间组件等。</li><li>调试方便。由于整个系统通过组件组合，在出现问题的时候，可以用排除法移除组件，或根据报错定位。由于每个组件之间低耦合，指责单一，所以逻辑会比分析整个系统简单</li><li>提高可维护性。组件指责单一，并且组件在系统中是复用的，所以对代码进行优化可以获得系统的整体升级。</li></ul></li><li>虚拟 DOM<ul><li>什么是虚拟 DOM<ul><li>虚拟 DOM（Virtual DOM）本质上是 JS 和 DOM 之间的一个映射缓存，它在形态上表现为一个能描述 DOM 结构及其属性信息的 JS 对象。它主要存储在内存中。主要来说：<ul><li>虚拟 DOM 是一个 JS 对象，存储在内存之中</li><li>虚拟 DOM 能够描述真实 DOM（存在一个映射关系）</li><li>当数据变化的时候，生成新的 DOM，对比新旧虚拟 DOM 的差异，将差异更新到真实 DOM 上</li></ul></li></ul></li><li>虚拟 DOM 的优点<ul><li>减少 DOM 操作：虚拟 DOM 可以将多次 DOM 操作合并为一次操作</li><li>研发效率的问题：虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。</li><li>跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”</li></ul></li></ul></li><li>React 和 Vue 中虚拟 DOM 的相同点<ul><li>二者都使用了 VirtualDOM + Diff 算法。不管是 Vue 的 Template + Options api 写法，还是 React 的 Class/Function 写法，最后都是生成 render 函数。而 render 函数执行返回 VNode（虚拟 DOM 的数据结构，本质上是一棵树）。当每一次 UI 更新的时候，总会根据 render 重新生成的 VNode，跟之前缓存起来的老 VNode 进行比对时，再使用 Diff 算法（框架核心）去真正更新真实 DOM（虚拟 DOM 是 JS 对象结构，同样在 JS 引擎中，在真实 DOM 在浏览器渲染引擎中，所以操作虚拟 DOM 比操作真实 DOM 开销要小的多）</li><li>（Vue Template/React JSX） -> render 函数 -> 生成 VNode -> 新老 VNode 进行 diff 算法对比 -> 更新真实 DOM</li><li>diff 算法源码实现的相同之处<ul><li>在处理老节点的部分，都需要把节点处理 key - value 的 Map 数据结构，方便在往后的比对中可以快速通过节点的 key 取到对应的节点。同样在比对两个新老节点是否相同时，key 是否相同也是非常重要的判断标准。所以不同是 React/Vue，在写动态列表的时候都需要设置一个唯一值 key，这样在 diff 算法处理的时候性能才能最大化。</li></ul></li></ul></li><li>React 和 Vue 中虚拟 DOM 的差别<ul><li><p>DOM 的更新策略不同</p><ul><li>在 React 中，当状态改变时，组件树会自顶向下全 diff，重新 render 页面。重新生成新的虚拟 DOM tree，新旧 DOM tree 进行比较，进行 patch 打补丁方式，局部更新 DOM。所以 React 为了避免父组件更新而引起不必要的子组件更新，可以在 shouldComponenUpdate 做逻辑判断，减少没必要的 render，以及重新生成虚拟 DOM，做差量对比过程</li><li>在 vue 中，通过 Object.defineProperty 把 data 属性全部转为 getter/setter。同时 watcher 实例对象会在组件渲染时，将属性记录为 dep，当 dep 项中的 setter 被调用时，通知 watcher 重新计算，使得关联组件更新。</li></ul></li><li><p>Diff 算法借助元素的 key 判断元素是新增、删除、修改，从而减小不必要的元素重渲染。</p></li><li><p>Diff 算法实现不同之处</p><ul><li>React 的 diff<ul><li>声明 newChildren 就是即将更新的 jsx 对象</li><li><ol><li>当 newChildren 类型为 object,number,string,代表同级只有一个节点</li></ol><ul><li>检查上次更新时的 fiber 节点是否存在对应的 DOM 节点<ul><li>存在：DOM 节点是否可以复用（通过 tag 和 key 进行判断）<ul><li>可以：将上次更新的 fiber 节点副本作为本次新生成的 fiber 节点并返回</li><li>不可以：标记当前节点为待删除节点，新生成一个 fiber 节点并返回</li></ul></li><li>不存在：新生成一个 fiber 节点并返回</li></ul></li></ul></li><li><ol start=2><li>当 newChildren 类型为 Array，同级有多个节点，会进行两次遍历：</li></ol><ul><li>第一层遍历：<ul><li>遍历 newChildren, i = 0,将 newChildren[i] 与 oldFiber 比较，判断 DOM 节点是否可以复用</li><li>如果可以复用，i++，比较 newChildren[i]与 oldFiber.sibling 是否可以复用。可以复用则重复此步骤。</li><li>如果不可复用，立即跳出遍历。</li><li>如果 newChildren 遍历完或者 oldFiber 遍历完(oldFiber.sibling === null)。跳出遍历。</li></ul></li><li>第二轮遍历：第二轮遍历的时候会将剩余未比较的老节点好剩余未比较的新节点进行遍历<ul><li>newChildren 没遍历完，oldFiber 遍历完：遍历余下的 newChildren 依次进行插入</li><li>newChildren 遍历完，oldFiber 没遍历完：遍历余下的 oldFiber 依次进行删除</li><li>newChildren 与 oldFiber 都没遍历完：意味着有节点在这次更新中改变了位置</li></ul></li></ul></li><li>更多 React-diff
<a href=https://juejin.cn/post/6844904167472005134 target=_blank>点击</a></li></ul></li><li>Vue 的 diff
patch 函数会接受两个参数： oldVnode 和 VNode<ul><li>1.只有新节点：createElm 创建新的节点</li><li>2.只有旧节点：删除旧节点</li><li>3.新旧节点都存在：通过 sameVNode 判断节点是否一样<ul><li>一样：直接调用 patchNode 去处理<ul><li>VNode 是文本节点，则更新文本</li><li>VNode 有子节点，则处理比较更新节点<ul><li>新旧节点都有子节点，而且不一样，那么执行 updateChildren(维持新旧节点首尾的四个指针进行遍历对比，遵循的原则：能不移动，尽量不移动，不行就移动，实在不行就新建)</li><li>只有新子节点：执行创建</li><li>只有旧子节点：执行删除</li></ul></li></ul></li><li>不一样：直接创建新节点，删除旧节点</li></ul></li></ul></li></ul></li><li><p>数据驱动视图（数据变化的时候，相应的视图会得到更新。开发者只需要关注数据的变化而不用再手动操作 DOM）</p><ul><li><p>Vue 中的数据驱动视图（Vuejs 的数据驱动是通过 MVVM 来实现的。MVVM 框架主要包含 3 个部分：model、view 和 viewModel）</p><ul><li>Model：数据部分，对应到前端就是 JavaScript 对象</li><li>View：视图部分，对应前端 DOM</li><li>ViewModel：连接视图与数据的中间件。ViewModel 是实现数据驱动视图的核心，当数据变化的时候，ViewModel 能够监听到这种变化，并及时通知 view 做出修改。同样的。当页面有事件触发的时候，ViewModel 也能够监听到事件，并通知 model 进行响应。ViewModel 相当于一个观察者，监控双方的动作，并及时通知对方进行相应的操作。首先，vuejs 在实例化的过程中，会对遍历传给实例化对象选项中的 data 选项，遍历其所有属性并使用 Object.defineProperty 把这些属性全部转为 getter/setter。
同时每一个实例对象都有一个 watcher 实例对象，他会在模板编译的过程中,用 getter 去访问 data 的属性，watcher 此时就会把用到的 data 属性记为依赖，这样就建立了视图与数据之间的联系。
当之后我们渲染视图的数据依赖发生改变（即数据的 setter 被调用）的时候，watcher 会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。这样就实现了所谓的数据对于视图的驱动。</li></ul></li><li><p>React 的数据驱动视图
先了解一些列内容：</p><ul><li>pending： 当前所有等待更新的 state 队列</li><li>isBatchingUpdates: React 中用于标识当前是否处理批量更新状态，默认 FALSE。</li><li>dirtyComponent：当前所有待更新 state 的组件队列
React 通过 setState 实现数据驱动视图，通过 setState 来引发一次组件的更新过程从而实现页面的重新渲染（除非 shouldComponentUpdate 返回 FALSE）。<ul><li>setState() 首先将接收的第一个参数 state 存储在 pending 队列中</li><li>判断当前 React 是否处于批量更新状态，是的话就需要更新 state 的组件添加到 dirtyComponent 中</li><li>不是的话，它会遍历 dirtyComponent 所有组件，调用 updateComponent 方法更新每个 dirty 组件</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>单页应用路由的实现原理（监听 URL 变化，渲染不同的页面组件）
主要有 history 和 hash 模式</p><ul><li>history 模式<ul><li>1.改变路由
-（history.pushState）<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要可以填null
</span></span></span><span style=display:flex><span><span style=color:#75715e>// title：新页面的标题。但是所有浏览器目前都忽略这个值，可填null
</span></span></span><span style=display:flex><span><span style=color:#75715e>// path：新的网址，必须与当前页面处在同一个域。浏览器的地址将显示这个地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>history</span>.<span style=color:#a6e22e>pushState</span>(<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>title</span>, <span style=color:#a6e22e>path</span>);
</span></span></code></pre></div><ul><li>（history.replaceState(state, title, path)）</li><li>与 history.pushState 一样，这个方法会修改当前的 history 对象记录，history.length 的长度不会改变</li></ul></li><li>2.监听路由
-（popstate事件）<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;popstate&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 监听改变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span></code></pre></div>同一个文档的history对象出现变化时，会触发popstate事件，history.pushState可以使浏览器地址改变，但是无需刷新页面。注意的是：用history.pushState()或history.replaceState()不会触发popstate事件。popstate事件只会在浏览器某些行为下触发（点击后退，前进按钮 或调用history.back(),history.forward(),history.go()方法）</li></ul></li><li>hash模式<ul><li>1.改变路由
通过<code>window.location.hash</code>属性获取和设置hash的值</li><li>2.监听路由
onhashchange<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;hashchange&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 监听改变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span></code></pre></div></li></ul></li></ul></li><li><p>package.json</p><ul><li>什么是 package.json</li><li>package.json 中的 dependency 与 devDpendency 字段的区别</li></ul></li><li><p>设置元素 background 的哪些区域颜色会改变</p><ul><li>background 填充区域默认为 content、padding、border 区域。该行为由 background-clip 属性决定（默认 content-box）。以下为 background 的填充对应区域：</li><li><table><thead><tr><th>background-clip</th><th>margin</th><th>border</th><th>padding</th><th>content</th><th>text</th></tr></thead><tbody><tr><td>border-box(default)</td><td>x</td><td>√</td><td>√</td><td>√</td><td>-</td></tr><tr><td>padding-box</td><td>x</td><td>x</td><td>√</td><td>√</td><td>-</td></tr><tr><td>content-box</td><td>x</td><td>x</td><td>x</td><td>√</td><td>-</td></tr><tr><td>text(webkit)</td><td>x</td><td>x</td><td>x</td><td>x</td><td>√</td></tr></tbody></table></li></ul></li><li><p>重排与重绘</p><ul><li>区别： 重绘不一定需要重排（改变颜色），重排一定导致重绘（改变网页的位置）</li><li>重排（reflow）<ul><li>当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树当中受影响的部分失效，并重新构造渲染树。</li></ul></li><li>重绘（repaint）<ul><li>是在一个元素的外观被改变时触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使得元素呈现新的外观。比如某个元素的 背景色，文字颜色，边框颜色等属性的改变。</li></ul></li><li>如何减少重排次数以及缩小重排的影响范围<ol><li>将多次改变样式属性的操作，整合到一次中修改。</li><li>将需要多次重排的元素，使其脱离文档流（定义 position 属性为 absolute/fixed）。</li><li>如果对一个元素进行复杂的操作，可以先定义 display 属性为 none，操作完成后再显示。</li><li>在需要经常获取那些引起浏览器重排的属性值时，先缓存到变量中。</li></ol></li></ul></li><li><p>JavaScript 的数据类型有哪些：</p><ul><li>基本类型： Number, String, Boolean, Undefined, Null, Symbol,</li><li>引用类型： Function, Object, Array</li><li>基本类型与引用类型的区别<ul><li>基本类型：基本类型的访问都是按值访问的，我们可以操作保存在变量中的实际的值。有如下特点：<ol><li>基本类型的值不可变</li><li>基本类型的比较是值的比较</li><li>基本类型的变量是存放在栈区中（即内存中的栈内存）</li></ol></li><li>引用类型：可以拥有属性与方法，属性又可以包含基本类型与引用类型。有如下特点：<ol><li>引用类型的值可变</li><li>引用类型的比较是引用的比较</li><li>引用类型的值是同时保存在栈内存和堆内存中的对象</li></ol></li></ul></li></ul></li><li><p>判断一个对象是不是数组</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>object</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>Array.<span style=color:#a6e22e>isArray</span>(<span style=color:#a6e22e>object</span>);
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>object</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>object</span>).<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;Array&#39;</span>);
</span></span></code></pre></div></li></ul></li><li><p>JS 事件循环机制</p><ul><li>Event Loop 包含两类，二者独立运行<ul><li>基于 Browsing Context</li><li>基于 Worker</li></ul></li><li>任务队列<ul><li>任务可以分为同步任务和异步任务。</li><li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中进行。</li><li>异步任务：异步执行的任务（Ajax，setTimeout），异步任务会通过任务队列（Event Queue）的机制来协调。</li><li>事件循环中，每进行一次循环操作称为一个 tick。每次 tick 的任务处理模型如下：<ol><li>在此次 tick 中选择最先进入队列的任务（oldest task）,如果有则执行（一次）</li><li>检查是否存在 Microtasks，如果存在则不断执行，直到 Microtask Queue 清空</li><li>更新 render</li><li>主线程重复执行上述步骤</li></ol></li></ul></li></ul></li><li><p>深拷贝与浅拷贝</p><ul><li>深拷贝（Deep Clone）：从堆内存中开辟一个新的区域存放新对象，将对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</li><li>实现方式：<ol><li>JSON.parse(JSON.stringify())</li><li>lodash 库的 _.deepClone</li><li>jQuery</li></ol></li><li>浅拷贝（Shallow Clone）： 重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li><li>实现方式：<ol><li>Object.assign</li><li>lodash 库的 _.clone</li><li>展开运算符 &mldr;</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li></ol></li></ul></li><li><p>箭头函数</p><ul><li>不绑定 this，其中的 this 指向函数定义位置的上下文 this</li><li>内部不存在 arguments 和 new.target，使用的都是外部的</li><li>没有原型，占用内存空间小</li></ul></li><li><p>JS 垃圾回收方法</p><ul><li>JavaScript 具有自动垃圾回收机制（GC：Garbage Collection）</li><li>原理：垃圾收集器会定期（周期性）找到不再继续使用的变量，销毁并释放内存<ol><li>标记清除法：在函数声明一个变量的时候，就将这个变量标记为”进入环境“</li><li>引用计数法：引用计数的含义是跟踪记录每个值被引用的次数，当被引用次数为 0 的时候，就将其占用的内存空间回收</li></ol></li></ul></li><li><p>如何监听一个变量的变化 长度 index</p><ul><li><p>defineProperty</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>targetObject</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>targetVal</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>latestVal</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>targetObject</span>.<span style=color:#a6e22e>targetVal</span>;
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>targetObejct</span>, <span style=color:#e6db74>&#39;targetVal&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>get</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;get:&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>targetVal</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>targetVal</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>set</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>val</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>targetVal</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>val</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>latestVal</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>targetVal</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>latestVal</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>targetVal</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;value changed. set: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>targetVal</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>targetObject</span>.<span style=color:#a6e22e>targetVal</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div></li></ul></li><li><p>Proxy</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>observer</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>object</span>, <span style=color:#a6e22e>onChange</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>property</span>, <span style=color:#a6e22e>receiver</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>target</span>[<span style=color:#a6e22e>property</span>], <span style=color:#a6e22e>handler</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>property</span>, <span style=color:#a6e22e>receiver</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>receiver</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>onChange</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>receiver</span>);
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>object</span>, <span style=color:#a6e22e>handler</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;abcd&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>y</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;z&#39;</span> },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span> }],
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>watchedObj</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>observer</span>(<span style=color:#a6e22e>obj</span>, (<span style=color:#a6e22e>val</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`监听到值变化为</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>val</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#a6e22e>watchedObj</span>.<span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;efgh&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>watchedObj</span>.<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>watchedObj</span>.<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span></code></pre></div></li></ul></li></ul></li><li><p>webpack loader / plugin</p><ul><li>loader 的使用方式<ul><li>1.在 webpack.config.js 中配置<pre tabindex=0><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.txt$/,
        use: &#39;raw-loader&#39;
      }
    ]
  }
}
</code></pre></li><li>2.通过命令行参数方式<pre tabindex=0><code>webpack --module-bind &#39;txt=raw-loader&#39;
</code></pre></li><li>3.通过内联使用<pre tabindex=0><code>import txt from &#39;raw-loader!./file.txt&#39;
</code></pre></li></ul></li><li>常用的 loader<ul><li>样式：style-loader, css-loader, less-loader, sass-loader 等</li><li>文件：raw-loader, file-loader, url-loader 等</li><li>编译：babel-loader, coffee-loader, ts-loader 等</li><li>测试：mocha-loader, jshint-loader, eslint-loader 等</li></ul></li></ul></li><li><p>地址栏输入一个 URL 地址到页面渲染的过程发生了什么</p></li><li><p>HTTP 请求准备阶段</p><ul><li><ol><li>构建请求：浏览器构建请求行（请求头，请求体）信息，准备发起网络请求 GET /index.html HTTP1.1</li></ol></li><li><ol start=2><li>查找缓存：如果浏览器发现请求的资源存在副本，根据强缓存规则，如果没有过期，则返回资源，如果查找失败则进入下一个环节：</li></ol><ul><li><ol><li>准备 ip 地址和端口</li></ol></li><li><ol start=2><li>DNS（域名和 ip 的映射系统）域名解析，拿到 ip 之后找端口，默认端口为 80</li></ol></li><li><ol start=3><li>建立 TCP 链接（三次握手，四次挥手）</li></ol></li><li><ol start=4><li>如果是 https 还需建立 TLS 连接</li></ol></li></ul></li></ul></li><li><p>HTTP 发送请求</p><ul><li>浏览器向服务器发起 http 请求，把请求头和请求行一起发送给服务器，服务端解析请求头。如果发现 cache-control 和 etag(if-none-match)，if-modified(if-modified-since)字段就会判断缓存是否过期，如果没有就返回 304，否则返回 200</li></ul></li><li><p>HTTP 响应返回</p><ul><li>浏览器拿到响应数据，首先判断是否是 4XX 或者 5XX 是就报错，如果是 3XX 就要重定向，2XX 就开始解析文件，如果是 gzip 就解压文件</li><li>TCP 断开连接</li><li>4 次挥手</li><li>浏览器解析渲染</li><li>根据 HTML 建立 DOM 树与 CSS 树，如果遇到 script 首选判断是否 defer 和 async 否则会阻塞渲染并编译执行 js，如果没有则组合生成 render tree，最后浏览器开启 GPU 进行绘制合成涂层，将内容显示到屏幕。</li></ul></li><li><p>content-type 的作用</p><ul><li>Content-Type 实体头部用于指示资源的 MIME 类型 media type。</li><li>在响应中，Content-Type 标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行 MIME 查找，并不一定遵循此标题的值。为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。</li><li>在请求中（如 POST/PUT 等），客户端告诉服务器实际发送的数据类型。</li><li>Content-Type 的值类型：<ul><li><ol><li>application/json: 消息主体是序列化后的 JSON 字符串</li></ol></li><li><ol start=2><li>application/x-www-form-urlencded: 数据被编码为名称/值对。这是标准的编码格式</li></ol></li><li><ol start=3><li>multipart/form-data: 需要在表单中进行文件上传时，就需要使用该格式。常见的媒体格式是上传文件时使用的</li></ol></li><li><ol start=4><li>text/plain: 数据以纯文本形式（text/json/xml/html）进行编码，其中不含任何控件或格式字符</li></ol></li></ul></li></ul></li><li><p>状态码介绍</p><ul><li><table><thead><tr><th>状态码</th><th>解析</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table></li><li>301：（永久移动）请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302：（临时移动）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置</li><li>HTTP 状态码 301 与 302 的区别<ul><li><ol><li>关键区别为，资源是否存在有效性</li></ol></li><li><ol start=2><li>301 资源还在只是换了一个位置，返回的是新位置的内容</li></ol></li><li><ol start=3><li>302 资源暂时失效，返回的是一个临时的代替页</li></ol></li></ul></li></ul></li><li><p>怎么减少页面加载时间</p><ul><li>压缩 css, js 文件</li><li>合并 js，css 文件，减少 http 请求</li><li>外部 js，css 文件，放在文件最底下</li><li>减少 dom 操作，尽可能用变量替代不必要的 dom 操作</li><li>优化图像（格式选择，懒加载等）</li><li>使用 CDN</li><li>使用缓存</li><li>合并文件，合并图片，减少 http 请求</li><li>标明高度和宽度</li><li>网址后加斜杆</li><li>优化 TCP 协议</li></ul></li><li><p>为什么要选择 Vue，Vue 解决了哪些问题</p></li><li><p>对 Vue 生命周期的理解</p></li><li><p>v-if / v-show 的区别</p></li><li><p>Vue.js 中 组件之间的通信手段</p></li><li><p>Vue 中的数据双向绑定</p></li><li><p>如果让你实现一个基本的双向数据绑定，有什么思路</p></li><li><p>MVVM 和 MVC 有什么区别</p></li><li><p>前端自动化测试框架的使用经历</p></li><li><p>JS 中的数据类型</p></li><li><p>JS 中 == 和 === 的区别</p></li><li><p>JS 中的深拷贝与浅拷贝有什么区别</p></li><li><p>如何实现一个深拷贝，有哪些思路</p></li><li><p>描述一下 对原型，构造函数，实例的理解</p></li><li><p>什么是闭包？闭包解决了什么问题？闭包会导致什么问题？</p></li><li><p>如何理解 JS 中的 this 关键词</p></li><li><p>做项目的时候是否碰到过跨域的问题？如何解决的？</p></li><li><p>P 元素和 div 元素，都是块元素，二者有什么区别</p></li><li><p>谈谈对 CSS 盒模型的理解</p></li><li><p>如何水平/垂直居中一个页面元素？有哪些实现方式</p></li><li><p>清除浮动的方式有哪些？它们之间有什么区别？</p></li><li><p>描述一下重绘和回流的区别</p></li><li><p>实现响应式布局的方式有哪些</p></li><li><p>有没有使用过 css 框架</p></li><li><p>当在浏览器输入 URL 到页面显示，中间过程发生了哪些事情？</p></li><li><p>在项目中遇到过哪些问题，当时是怎么解决的</p></li><li><p>项目中有哪些亮点可以分享</p></li><li><p>package.json 有什么作用？包含了哪些内容</p></li><li><p>对 webpack 的使用有哪些优化建议</p></li><li><p>撇开 Vue，react，等框架。你认为前端应该会的技能（知识点）有哪些</p></li><li><p>对前端工程化的理解</p></li><li><p>能否徒手从零构建一个工程化项目</p></li><li><p>类的使用的理解, 新建一个 Person 类，用构造函数定义 setName, getName, 并用 User 继承 Person 类。</p></li><li><p>对 typescript 的理解，平时是否有写过脱离框架的 ts 的使用</p></li><li><p>是否封装过组件？是如何封装的</p></li><li><p>Vue 业务层的代码是如何编写的</p></li><li><p>怎么实现跨域请求数据</p></li><li><p>响应式和自适应</p><ul><li>响应式(RWD) && 自适应(AWD)<ul><li>响应式(RWD): 所有设备的代码是一样的；自适应(AWD): 不同设备的代码是不一样的</li><li>RWD: Ethan.M 提出 RWD 是采用 CSS 的 media query 技术，配合流体布局(fluid grids) 和同样可以自适应的图片/视频等素材。RWD 倾向于只改变元素的外观布局，而不大幅度改变内容。</li><li>AWD：Adaptive Design 是 Aaron G. 的一本技术书的标题,他认为 AWD 在包括 RWD 的 CSS media query 技术以外，AWD 有可能会针对移动端用户减去内容，减去功能。AWD 可以在服务器端就进行优化，把优化的内容送到终端上。</li></ul></li></ul></li><li><p>排序算法</p></li><li><p>设计模式，在 Vue 中 或在开发过程中，有哪些常用的开发模式</p></li><li><p>你对前端工程化的理解</p></li><li><p>为什么要前端工程化</p></li><li><p>前端性能优化的手段有哪些</p></li><li><p>HTTP 缓存</p></li><li><p>Vue 数据驱动原理</p></li><li><p>Vue 如何让视图刷新</p></li><li><p>webpack 配置中，生产环境与生产环境的不同配置</p></li></ul></article></div></div></div><aside class="column single-sidebar is-one-quarter"><div class=card><div class=card-info><div class=avatar><div class="image-wrapper ratio-1x1"><img src=/images/_avatar.jpg></div></div><div class=info><span class=info-name>WannTonn</span>
<span class=info-para>为他人期待而活才是小丑🤡</span></div><div class=counter><div class=counter-wrapper><span class=counter-data>26</span>
<span class=counter-name>kWords</span></div><div class=counter-wrapper><span class=counter-data>11</span>
<span class=counter-name>Tags</span></div><div class=counter-wrapper><span class=counter-data>32</span>
<span class=counter-name>Posts</span></div></div></div></div><div class=sticky><div class="card toc hidden" id=table-of-contents><nav id=TableOfContents></nav></div></div></aside></div></div></main><footer class=footer><div class=container><span>Copyright &copy; 2020-2023 WannTonn</span>
<span>Original theme <a href=https://github.com/amzrk2/hugo-template-aofuji target=_blank>Aofuji</a> with Apache-2.0 license</span></div></footer><script defer src=/assets/amzrk2-common.min.js></script>
<script defer src=/assets/amzrk2-single.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.21.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.21.0/plugins/autoloader/prism-autoloader.min.js></script></body></html>