<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.110.0"><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=manifest href=/favicons/site.webmanifest><link rel="shortcut icon" href=/favicons/favicon.ico><title>前端学习路线 - Javascript - {...Life}</title><meta name=author content="WannTonn"><meta name=keywords content="Code"><meta property="og:title" content="前端学习路线 - Javascript"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://blogs.wanntonn.fun/fed/interview/js/"><meta property="og:image" content="https://blogs.wanntonn.fun/images/Code/javascript.png"><meta property="article:published_time" content="2023-02-17T23:35:24+08:00"><meta property="article:modified_time" content="2023-02-17T23:35:24+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blogs.wanntonn.fun/images/Code/javascript.png"><meta name=twitter:title content="前端学习路线 - Javascript"><meta name=twitter:description content><link rel=stylesheet href=/assets/amzrk2.min.css><script></script><body data-theme=auto data-section=single><script>!function(e){let t;try{t=JSON.parse(localStorage.getItem("amzrk2-theme"))}catch{t=null}t&&t!==e&&document.body.setAttribute("data-theme",t)}(document.body.getAttribute("data-theme"))</script><div id=top style=height:0;overflow:hidden></div><header><nav class=navbar><div class=container><div class=navbar-brand><a class=navbar-item href=https://blogs.wanntonn.fun>{...Life}</a></div><div class=navbar-menu><div class=navbar-start><a class=navbar-item href=/fed/>前端</a>
<a class=navbar-item href=/hackintosh/>MacOS</a>
<a class=navbar-item href=/tags/>标签</a>
<a class=navbar-item href=/about/>关于</a></div><div class=navbar-end><div class=navbar-item id=ctrl-adjust><svg class="icon" aria-hidden="true"><use xlink:href="#icon-adjust"/></svg></div><a class=navbar-item id=ctrl-rss href=/index.xml target=_blank><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss"/></svg></a><div class=navbar-item id=ctrl-toc><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bars"/></svg></div></div></div></nav></header><main><div class="container single-container"><div class="columns single-columns"><div class="column single-content is-three-quarters"><div class=card><div class="post-image image-wrapper ratio-32x9"><img src=/images/Code/javascript.png></div><div class=post-box><h2 class=post-title>前端学习路线 - Javascript</h2><div class=post-meta><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-day"/></svg>&nbsp;<time>2023-02-17</time></span>
<span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clock"/></svg>&nbsp;12 min</span>
<span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hashtag"/></svg>&nbsp;<a href=/tags/code>Code</a></span></div></div><div class=post-content><article class="markdown content"><ul><li><p>执行上下文</p><ul><li>什么是执行上下文（context）<ul><li>是评估和执行 JavaScript 代码环境的抽象概念，每当 JavaScript 代码运行的时候，它都是在执行上下文中运行</li></ul></li><li>执行上下文的类型<ul><li>全局执行上下文<ul><li>默认或是基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：1.创建一个全局的 window 对象（浏览器环境下），并设置 this 的值等于这个全局对象，一个程序中只会有一个全局执行上下文</li></ul></li><li>函数执行上下文<ul><li>每当一个函数被调用时，都会为该函数创建一个新的上下文，每个函数都有他自己的执行上下文，不过是在函数被调用的时候创建的，函数上下文可以有任意个，每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤</li></ul></li><li>Eval 函数执行上下文<ul><li>执行在 eval 函数内的代码也会有属于他自己的执行上下文。</li></ul></li></ul></li><li>执行栈（一种拥有 LIFO&lt;后进先出>数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当 JavaScript 引擎第一次运行该脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行那些执行上下文栈顶的函数。当该函数执行结束时，执行上下文会从栈中弹出，控制流程达到前栈中的下一个上下文。） -创建执行上下文<ul><li>创建阶段<ul><li>this 值的决定（this 绑定）<ul><li>全局执行上下文：指向的是全局对象（浏览器中是指的 window 对象）</li><li>函数执行上下文：this 指向的值取决于该函数是如何被调用的，若被引用对象调用，那么 this 会被设置成那个对象，否则 this 的值会被设置为全局对象或者 undefined（严格模式下）</li></ul></li><li>创建语法环境组件<ul><li>概念（词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境和空值组成）</li><li>环境记录器（是存储变量和函数声明的实际位置）</li><li>外部环境的引用（意味着它可以访问其父级词法环境（作用域））</li><li>类型<ul><li>全局环境（在全局执行上下文中，是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object/Array 等。在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 this 的值指向全局对象）</li><li>函数环境（在函数环境中，函数内部用户定义的变量存储在环境记录器重。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数）</li></ul></li></ul></li><li>创建变量环境组件</li></ul></li><li>执行阶段<ul><li>变量赋值</li><li>函数引用</li><li>执行其他代码</li></ul></li></ul></li></ul></li><li><p>JavaScript 的作用域链</p><ul><li>作用域<ul><li>概念（作用域是一个独立的域，让变量不会外泄，对外暴露。也就是说作用域最大的作用是隔离变量，不同作用域下同名变量不会有冲突）</li><li>分类<ul><li>函数作用域（只能在函数内部才能访问的变量，也可以利用闭包来实现跨区域访问局部作用域的变量）</li><li>块级作用域（ES6 新增，用 let/const 命令定义块级作用域的变量，外层作用域无法获取到内层作用域，即使外层和内层都使用同名变量名，也不会被干扰）</li></ul></li></ul></li><li>作用域链（当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条））</li></ul></li><li><p>JavaScript 的闭包</p><ul><li>概念（闭包是指有权访问另一个函数作用域中的变量和函数。创建闭包的方式就是在一个函数内部创建另一个函数）</li><li>引用场景（存在的意义）（放置那些声明函数的词法环境里，被标记了进入环境，没有标记离开环境的变量（没有被回收的变量）供函数使用）</li></ul></li><li><p>this/call/apply/bind</p><ul><li>this（this 对象是在运行时基于函数的执行环境绑定的）<ul><li>全局函数执行上下文 （this 指向 window）</li><li>函数执行上下文<ul><li>直接调用：this 指向函数对象</li><li>call，apply：this 指向绑定的对象上</li><li>bind：this 将永久地被绑定到了 bind 的第一个参数</li></ul></li><li>匿名函数（因匿名函数执行环境具有全局性，因此 this 通常指 window）</li><li>箭头函数（所有的箭头函数没有自己的 this，都指向外层）</li><li>new 绑定（当 new 操作符调用构造函数时，this 其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象 p1 接收。因此，我们可以说，这个时候，构造函数的 this，指向了新的实例对象：p1）</li></ul></li><li>改变 this 的指向 - apply、call、bind、箭头函数、new 绑定</li><li>call 和 apply 的区别<ul><li>call<ul><li>语法（fn.call(thisArg,arg1,arg2,&mldr;)）</li><li>概念（call()方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数）</li><li>参数<ul><li>thisArg(this 指向，第一个参数)<ul><li>不传/null/undefined，函数中的 this 指向 window 对象</li><li>传递另一个函数的函数名，函数中的 this 指向这个函数的引用，并不一定是该函数执行时真正的 this 值</li><li>值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象，如 String，Number，Boolean</li><li>传递一个对象，函数中的 this 指向这个对象</li></ul></li><li>arg1，arg2&mldr;（指定的参数列表）</li></ul></li><li>返回值（使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined）</li></ul></li><li>apply<ul><li>语法（fn.apply(thisArg, args[])）</li><li>概念（apply()方法调用一个具有给定 this 值的函数，以及以一个数组（或类数组对象）的形式提供的参数）</li><li>参数<ul><li>thisArg（同 call）</li><li>args（一个数组或类数组对象，其中的数组元素将作为单独的参数传给 fn 函数，如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript5 开始可以使用类数组对象）</li></ul></li><li>返回值（调用有指定 this 值和参数的函数的结果）</li></ul></li><li>区别 （第二个参数不同）</li></ul></li><li>bind<ul><li>语法（fn.bind(thisArg[,arg1[,arg2[,&mldr;]]])）</li><li>概念（bind()方法创建一个新的函数，在 bind()被调用时，这个新函数被指定为 bind()的第一个参数，而其余参数作为新函数的参数，供调用时使用）</li><li>参数<ul><li>thisArg（调用绑定函数作为 this 参数传递给目标函数的值。如果使用 new 运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 Object。如果 bind 函数的参数列表为空，或者 thisArg 是 null/undefined，执行作用域的 this 将被视为新函数的 thisArg）</li><li>arg1[,arg2[,&mldr;]]（当目标函数被调用时，被预置入绑定函数的参数列表中的参数）</li></ul></li><li>返回值（返回一个原函数的拷贝，并拥有指定的 this 值和初始参数）</li></ul></li></ul></li><li><p>原型/继承</p><ul><li><p>创建对象有几种方法</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 1.字面量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o1</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;o1&#39;</span> };
</span></span><span style=display:flex><span><span style=color:#75715e>// 与o1一致
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object({ <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;o2&#39;</span> });
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.通过构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>// M是构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>M</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>name</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>// o3是实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o3</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>M</span>(<span style=color:#e6db74>&#39;o3&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出M的原型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>M</span>.<span style=color:#a6e22e>prototype</span>); <span style=color:#75715e>// Object {constructor: function(name) {}, __proto__: Object }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>M</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>constructor</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>M</span>); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o3</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>M</span>.<span style=color:#a6e22e>prototype</span>); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 3.Object.create
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>P</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;o4&#39;</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o4</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>P</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>M</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>say</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;say hi&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o5</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>M</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// new 运算符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>new2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>func</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>func</span>.<span style=color:#a6e22e>prototype</span>); <span style=color:#75715e>// 继承构造函数的原型对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>func</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>o</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;object&#39;</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>o</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o6</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>new2</span>(<span style=color:#a6e22e>M</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o6</span>); <span style=color:#75715e>// M {name: undefined}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o6</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>M</span>); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o6</span> <span style=color:#66d9ef>instanceof</span> Object); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o6</span>.<span style=color:#a6e22e>__proto__</span>.<span style=color:#a6e22e>constructor</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>M</span>); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>M</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>walk</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;walk&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o6</span>.<span style=color:#a6e22e>walk</span>()); <span style=color:#75715e>// walk
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o3</span>.<span style=color:#a6e22e>walk</span>()); <span style=color:#75715e>// walk
</span></span></span></code></pre></div></li></ul></li><li><p><a class=image-link href=/images/interview/object-prototype.jpg target=_blank><img src=/images/interview/object-prototype.jpg alt></a></p></li><li><p>原型(对象):（原型是JS实现继承的主要方式。用constructor的时候，产生一个实例，实例.__proto__指向构造函数的原型对象，也就是构造函数.prototype。构造函数.prototype.constructor指向构造函数的本身，构造函数.prototype.__proto__指向Object的实例对象，也就是构造函数.prototype.__proto__指向Object的原型对象，然后再从实例.Object.__proto__指向Obj.prototype这个过程，它都是原型上的__proto__然后直接往上指的底边就形成一条原型链，最终指向null。即Object.prototype.<strong>proto</strong> === null）</p></li><li><p>原型链</p></li><li><p>构造函数：new Fn() 用 new 构造实例的函数叫做构造函数，生成函数的时候就会生成原型对象（prototype）.函数也是对象，所以函数也有<strong>proto</strong></p></li><li><p>实例：例子中的 o1，o2，o3 都叫做实例</p></li><li><p>instanceof 的原理</p><ul><li><a class=image-link href=/images/interview/instanceof.jpg target=_blank><img src=/images/interview/instanceof.jpg alt></a></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>o3</span> <span style=color:#66d9ef>instanceof</span> Object; <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>o3</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>M</span>.<span style=color:#a6e22e>prototype</span>; <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>M</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> Object.<span style=color:#a6e22e>prototype</span>; <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>o3</span>.<span style=color:#a6e22e>__proto__</span>.<span style=color:#a6e22e>constructor</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>M</span>; <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>o3</span>.<span style=color:#a6e22e>__proto__</span>.<span style=color:#a6e22e>constructor</span> <span style=color:#f92672>===</span> Object; <span style=color:#75715e>// false
</span></span></span></code></pre></div></li></ul></li><li><p>new 运算符</p><ul><li><ol><li>一个新对象被创建。它继承自 foo.prototype</li></ol></li><li><ol start=2><li>构造函数 foo 被执行，执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例。new foo 等同于 new foo()，只能用在不传递任何参数的情况。</li></ol></li><li><ol start=3><li>如果构造函数返回了一个“对象”，那么这个对象会取代整个 new 出来的结果。如果构造函数没有返回对象，那么 new 出来的结果为步骤 1 创建的对象。</li></ol></li></ul></li><li><p>面相对象</p><ul><li>类的声明<ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Animal</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;name&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ES6 class的声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Anamal2</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 实例化注册对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Animal</span>(), <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Animal2</span>()); <span style=color:#75715e>// Animal{name: &#39;name&#39;} Animal2{name: &#34;&#34;}
</span></span></span></code></pre></div></li></ul></li></ul></li><li><p>实现继承的几种方式</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 1.借助构造函数继承
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Parent1</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;parent1&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>Parent1</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>sayHa</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;say ha&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Child1</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Parent1</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>this</span>); <span style=color:#75715e>// 原理：将父级中的构造函数的属性 指向Child1的实例。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;child1&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child1</span>().<span style=color:#a6e22e>sayHa</span>(); <span style=color:#75715e>// 缺点： Uncaught TypeError: (intermediate value).say is not a function; 因为没有继承父类原型对象上的方法导致没有完全继承父类的属性。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2. 借助原型链实现继承
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Parent2</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;parent2&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>play</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Child2</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;child2&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>Child2</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Parent2</span>(); <span style=color:#75715e>// 使函数的实例能访问到原型对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child2</span>()); <span style=color:#75715e>// {type: &#34;child2&#34;, __proto__: Parent2}
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 原型链实现继承的缺陷
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child2</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child2</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>play</span>, <span style=color:#a6e22e>s2</span>.<span style=color:#a6e22e>play</span>); <span style=color:#75715e>// [1,2,3] [1,2,3]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>play</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 实例的原型对象没有隔离，操作实例原型对象的属性，会影响到其他的实例。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>play</span>, <span style=color:#a6e22e>s2</span>.<span style=color:#a6e22e>play</span>); <span style=color:#75715e>// [1,2,3,4] [1,2,3,4]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. 组合方式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Parent3</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;parent3&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>play</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Child3</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Parent3</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;child3&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>Child3</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Parent3</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 缺陷：父类的构造函数被创建多次。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s3</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child3</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s4</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child4</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>play</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>play</span>, <span style=color:#a6e22e>s4</span>.<span style=color:#a6e22e>play</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 4. 组合继承方式 - 优化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Parent4</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;parent4&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>play</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Child4</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Parent4</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;child4&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Child4</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Parent4</span>.<span style=color:#a6e22e>prototype</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s5</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child4</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s6</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child4</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// s5.play.push(4);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s5</span>, <span style=color:#a6e22e>s6</span>); <span style=color:#75715e>// 2个值相等
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 缺点：无法判断s5是由Child4实例化还是由Parent4直接实例化，因为构造函数相同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s5</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>Child4</span>, <span style=color:#a6e22e>s5</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>Parent4</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s5</span>.<span style=color:#a6e22e>constructor</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 5. 组合继承方式- 优化2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Parent5</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;parent5&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>play</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Child5</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Parent5</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;child5&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Child5</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>Parent5</span>.<span style=color:#a6e22e>prototype</span>); <span style=color:#75715e>// 通过Object.create创建一个中间对象，将原型对象区分开。通过__proto__往回追溯。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 缺点 Child5没有自己的constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 解决方案：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Child5</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>constructor</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Child5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s7</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child5</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s7</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>Child5</span>, <span style=color:#a6e22e>s7</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>Parent5</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>s7</span>.<span style=color:#a6e22e>constructor</span>);
</span></span></code></pre></div></li></ul></li></ul></li><li><p>跨域通信的几种方式</p><ul><li>jsonp （利用 script 标签的异步属性）</li><li>Hash （URL 中#号后面的字符发生改变，页面不会发生跳转（search 改变会跳转））</li><li>PostMessage</li><li>Websocket</li><li>CORS （跨域请求在 header 中添加 CORS-cross-origin，如果服务器不接收这个变量，则拒绝请求，浏览器会主动发起拦截。）</li></ul></li><li><p>网站安全</p><ul><li>CSRF（跨站请求伪造）<ul><li>原理：引诱用户点击钓鱼网站的请求 API 接口并带上 cookie，进而发送给被攻击的网站，实现 API 调用（需要登录）</li><li>解决方案： 1.添加 token 请求验证， 2.服务器添加 Referer 验证， 3.隐藏令牌（在请求头中添加 token）</li></ul></li><li>XSS （跨域脚本攻击）<ul><li>原理：在富文本编辑器中注入 script 脚本，</li><li>解决方案：将富文本内容中的 script 脚本清洗。让其无法执行。</li></ul></li></ul></li><li><p>深/浅拷贝</p><ul><li>基本数据类型（简单的数据段 保存在栈中，保存在内存中的一个位置。基本类型有：String, Number, Undefined, Null, Symbol, Boolean）</li><li>引用数据类型（保存在堆内存中的对象，所以引用类型的值保存的是一个指针，这个指针指向存储在堆中的对象。除了上述 6 种基本类型。剩下的就是引用类型。统称为 Object 类型。分别有：Object，Array，Date，RegExp，Function 等）</li></ul></li><li><p>渲染机制</p><ul><li><p>DOCTYPE 及作用</p><ul><li>DOCTYPE 告诉浏览器当前文档用哪个版本的DTD。</li><li>DTD&lt;document type definition, 文档类型定义>。 是一系列的语法法则，用来定义 XML/XHTML 的文件类型。浏览器会使用它来判断文档类型，决定使用哪种协议来解析，以及切换浏览器模式（HTML4版本所有：严格模式/传统模式）<ul><li>html5:<!doctype html></li><li>html4.01 Strict：包含所有HTML元素和属性，但不包括展示性和弃用的元素（比如font）</li><li>html4.01 Trasitional：包含所有HTML元素和属性，包括展示性和弃用的元素（比如font）</li></ul></li></ul></li><li><p>浏览器渲染过程（输入 URL 到渲染）</p><ul><li><a class=image-link href=/images/interview/browser-render.png target=_blank><img src=/images/interview/browser-render.png alt></a></li><li><ol><li>浏览器解析HTML，生成DOM Tree （Parse HTML）</li></ol></li><li><ol start=2><li>浏览器解析CSS，生成CSSOM Tree</li></ol></li><li><ol start=3><li>JavaScript通过DOM API和CSSOM API来操作DOM Tree 和CSS Rule Tree，浏览器将DOM Tree 和 CSSOM Tree合成渲染树（Render Tree）</li></ol></li><li><ol start=4><li>布局（layout），根据生成的Render Tree，进行回流，以计算每个节点的几何信息（位置，大小，字体样式等）</li></ol></li><li><ol start=5><li>绘制（painting），根据渲染树和回流得到的几何信息，得到每个节点的绝对像素</li></ol></li><li><ol start=6><li>展示（display），将像素发送给图形处理器（GPU），展示到页面上</li></ol></li></ul></li><li><p>重排 Reflow（DOM结构中的各个元素都有自己的盒子，当浏览器修改了该盒子的部分属性时，浏览器会根据其修改的属性，重新绘制并渲染。这个过程就叫重排），以下为触发Reflow的几个方式</p><ul><li>增加、删除、修改DOM节点时，会导致Reflow/Repaint</li><li>移动DOM的位置，或是做动画时</li><li>修改CSS样式时 （width, height, display）</li><li>Resize窗口，或是滚动的时候(可能)</li><li>修改网页的默认字体时</li></ul></li><li><p>重绘 Repaint</p><ul><li>当定义盒子的位置、大小以及其他（颜色，字体大小）等属性都确定下来后，浏览器便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现，这个过程称之为Repaint，触发Repaint有以下方式：<ul><li>DOM改动</li><li>CSS改动</li></ul></li><li>如何最大程度高效Repaint<ul><li>一个节点的多次Repaint操作放一次执行</li></ul></li></ul></li></ul></li><li><p>JS 运行机制</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 异步任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>setTimeout</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 依次输出 1,3,2
</span></span></span></code></pre></div></li><li>异步任务<ul><li>setTimeout / setInterval</li><li>DOM事件</li><li>ES6中的Promise</li></ul></li><li>总结<ul><li>理解JS的单线程的理念</li><li>理解任务队列</li><li>理解Event Loop</li><li>理解哪些语句会放入异步任务队列</li><li>理解语句放入异步任务队列的时机</li></ul></li></ul></li><li><p>页面性能</p><ul><li>提升性能<ul><li>资源压缩合并，减少http请求</li><li>非核心代码异步加载 -> 异步加载的方式 -> 异步加载的区别<ul><li>异步加载的方式<ul><li>动态脚本加载(用js创建标签后进行渲染)</li><li>defer</li><li>async</li></ul></li><li>异步加载的区别<ul><li>defer：在HTML解析完成之后才执行，如果是多个，按照加载的顺序依次执行</li><li>async：在加载完之后立即执行，如果是多个，执行顺序与加载顺序无关（先加载先执行）</li></ul></li></ul></li><li>利用浏览器缓存 -> 缓存的分类 -> 缓存的原理</li><li>使用CDN</li><li>与解析DNS<ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>// https协议默认关闭dns预解析，用这个标签强制打开a标签预解析
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>http-equiv</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;x-dns-prefetch-control&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;on&#34;</span> &gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dns-prefetch&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;//host_name_to_prefetch.com&#34;</span>&gt;
</span></span></code></pre></div></li></ul></li></ul></li><li>异步加载</li></ul></li><li><p>错误监控</p></li><li><p>新大陆支付</p></li><li><p>在登录页面加的倒计时，需要销毁吗</p></li><li><p>登录页面加的倒计时在进到其他页面的时候，返回的话。这个倒计时是否还在</p></li><li><p>如果在登录页面加一个interval，在interval中写入console，那组件销毁后，console是否还在。</p></li><li><p>如果想要封装一个http库，思路是什么</p></li><li><p>如果想要在这个http库中发起重试，该怎么写</p></li><li><p>关于HOC与hooks的区别</p></li><li><p>typescript如何规范class的字段</p></li><li><p>如果不知道接受的参数的字段类型，那如何定义？（泛型）</p></li><li><p>是否了解过洋葱模型</p></li><li><p>除了框架之外，是否还有了解其他技术</p></li><li><p>兴业证券</p></li><li><p>React中的useEffect</p></li><li><p>React中的useRef</p></li><li><p>css 中的盒模型</p></li><li><p>background-size 中 100% 100% 和cover和contain的差别</p></li><li><p>在quickfox项目中，前端与原生通信的方式，如何触发</p></li><li><p>封装过哪些组件，细说</p></li><li><p>有了解过H5中的REM么，是怎么实现的</p></li><li><p>babel-preset 与 babel-runtime的差别，与优先级</p></li><li><p>babel-pollyfill 与 babel-preset的区别</p></li><li><p>git冲突，（细指开发流程，从拉取代码到合并代码）</p></li><li><p>开发时项目中有哪些分支，各分支的角色是什么</p></li></ul></article></div></div></div><aside class="column single-sidebar is-one-quarter"><div class=card><div class=card-info><div class=avatar><div class="image-wrapper ratio-1x1"><img src=/images/_avatar.jpg></div></div><div class=info><span class=info-name>WannTonn</span>
<span class=info-para>为他人期待而活才是小丑🤡</span></div><div class=counter><div class=counter-wrapper><span class=counter-data>34</span>
<span class=counter-name>kWords</span></div><div class=counter-wrapper><span class=counter-data>12</span>
<span class=counter-name>Tags</span></div><div class=counter-wrapper><span class=counter-data>34</span>
<span class=counter-name>Posts</span></div></div></div></div><div class=sticky><div class="card toc hidden" id=table-of-contents><nav id=TableOfContents></nav></div></div></aside></div></div></main><footer class=footer><div class=container><span>Copyright &copy; 2020-2023 WannTonn</span>
<span>Original theme <a href=https://github.com/amzrk2/hugo-template-aofuji target=_blank>Aofuji</a> with Apache-2.0 license</span></div></footer><script defer src=/assets/amzrk2-common.min.js></script>
<script defer src=/assets/amzrk2-single.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.21.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.21.0/plugins/autoloader/prism-autoloader.min.js></script></body></html>