<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.83.1" />


<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico" />



<title> - My New Hugo Site</title>





<meta property="og:title" content="" />
<meta name="twitter:title" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wanntonn.github.io/posts/2021-03-31-fed-questions/" /><meta property="og:description" content="前端 JavaScript 问答题目收录 摘录自 Github。同步更新中。  1.输出是什么？ 2021-03-31
 function sayHi() { console.log(name); console.log(age); var name = &#34;Lydia&#34;, let age = 21 }  A: Lydia 和 undefined B: Lydia 和 ReferenceError C: ReferenceError 和 21 D: undefined 和 ReferenceError  答案: D 在函数内部，我们首先通过 var 关键字声明了 name 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 undefined。因为当我们打印 name 变量时还没有执行到定义变量的位置，因此变量的值保持为 undefined。
通过 let 和 const 关键字声明的变量也会提升，但是和 var 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 ReferenceError 错误。
  2.输出是什么？2021-04-01
 for (var i = 0; i &lt; 3; i&#43;&#43;) { setTimeout(() =&gt; console." />
<meta name="twitter:description" content="前端 JavaScript 问答题目收录 摘录自 Github。同步更新中。  1.输出是什么？ 2021-03-31
 function sayHi() { console.log(name); console.log(age); var name = &#34;Lydia&#34;, let age = 21 }  A: Lydia 和 undefined B: Lydia 和 ReferenceError C: ReferenceError 和 21 D: undefined 和 ReferenceError  答案: D 在函数内部，我们首先通过 var 关键字声明了 name 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 undefined。因为当我们打印 name 变量时还没有执行到定义变量的位置，因此变量的值保持为 undefined。
通过 let 和 const 关键字声明的变量也会提升，但是和 var 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 ReferenceError 错误。
  2.输出是什么？2021-04-01
 for (var i = 0; i &lt; 3; i&#43;&#43;) { setTimeout(() =&gt; console." /><meta name="twitter:card" content="summary" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://wanntonn.github.io/assets/css/fuji.min.css" />








</head>

<body
  data-theme="auto"
  data-theme-auto='false'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://wanntonn.github.io/">My New Hugo Site</a>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://wanntonn.github.io/posts/2021-03-31-fed-questions/"></a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;0001-01-01</span>



<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;No tag</span>

    </div>
    
    <div class="post-content markdown-body">
        <h1 id="前端-javascript-问答题目收录">前端 JavaScript 问答题目收录</h1>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="摘录自-a-hrefhttpsgithubcomlydiahalliejavascript-questionsblobmasterzh-cnreadme-zh_cnmd-target_blankgithuba同步更新中">摘录自 <!-- raw HTML omitted -->Github<!-- raw HTML omitted -->。同步更新中。</h2>
<blockquote>
<p>1.输出是什么？ 2021-03-31</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHi</span>() {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">age</span>);
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Lydia&#34;</span>,
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>
}
</code></pre></div><ul>
<li>A: Lydia 和 undefined</li>
<li>B: Lydia 和 ReferenceError</li>
<li>C: ReferenceError 和 21</li>
<li>D: undefined 和 ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
在函数内部，我们首先通过 var 关键字声明了 <code>name</code> 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 <code>undefined</code>。因为当我们打印 <code>name</code> 变量时还没有执行到定义变量的位置，因此变量的值保持为 undefined。</p>
<p>通过 let 和 const 关键字声明的变量也会提升，但是和 var 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 ReferenceError 错误。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>2.输出是什么？2021-04-01</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
  <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>), <span style="color:#ae81ff">1</span>);
}
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
  <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>), <span style="color:#ae81ff">1</span>);
}
</code></pre></div><ul>
<li>A: 0 1 2 和 0 1 2</li>
<li>B: 0 1 2 和 3 3 3</li>
<li>C: 3 3 3 和 0 1 2</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted --></p>
<p>JavaScript 的事件循环，setTimeout 回调会在遍历结束后才执行。因为在第一个遍历中 index i 是通过 var 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，通过一元操作符++ 来每次递增 i 的值。当 setTimeout 回调执行的时候，i 的值等于 3。</p>
<p>在第二个遍历中，遍历 i 是通过 let 关键字声明的: 通过 let 和 const 关键字声明的变量是拥有块级作用域(指的是任何在{}中的内容)。在每次遍历过程中，i 都有一个新值，并且每个值都在循环内的作用域中。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>3.输出是什么？ 2021-04-01</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shape</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">radius</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>,
  <span style="color:#75715e">// 直径
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">diameter</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">radius</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
  },
  <span style="color:#75715e">// 周长
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">perimeter</span><span style="color:#f92672">:</span> () =&gt; <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> Math.<span style="color:#a6e22e">PI</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">radius</span>,
};

<span style="color:#a6e22e">shape</span>.<span style="color:#a6e22e">diameter</span>();
<span style="color:#a6e22e">shape</span>.<span style="color:#a6e22e">perimeter</span>();
</code></pre></div><ul>
<li>A: 20 和 62.83185307179586</li>
<li>B: 20 和 NaN</li>
<li>C: 20 和 63</li>
<li>D: NaN 和 63</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted --></p>
<p>!!! diameter 的值是一个常规函数，但是 perimeter 的值是一个箭头函数
对于箭头函数，this 关键字指向的是它当前周围作用域(简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象), 这个行为和常规函数不同。这意味着当我们调用 perimeter 时，this 不是指向 shape 对象，而是它的周围作用域(在这里指向 window)。</p>
<p>在 window 中没有 <code>radius</code> 属性，因此返回 <code>undefined</code>。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>4.输出是什么？ 2021-04-02</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#f92672">+</span><span style="color:#66d9ef">true</span>;
<span style="color:#f92672">!</span><span style="color:#e6db74">&#39;Lydia&#39;</span>;
</code></pre></div><ul>
<li>A: 1 and false</li>
<li>B: false and NaN</li>
<li>C: false and false</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted --></p>
<p>一元操作符加号尝试将 bool 转为 number。 true 转换为 number 的话为 1， false 为 0.
字符串 ‘Lydia’ 是一个真值， 真值取反即为 false。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>5.哪一个是正确的？ 2021-04-03</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bird</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">size</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;small&#39;</span>,
};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">mouse</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Mickey&#39;</span>,
  <span style="color:#a6e22e">small</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
};
</code></pre></div><ul>
<li>A: mouse.bird.size 是无效的</li>
<li>B: mouse[bird.size] 是无效的</li>
<li>C: mouse[bird[&ldquo;size&rdquo;]] 是无效的</li>
<li>D: 以上三个选项都是有效的</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted --></p>
<p>在 JavaScript 中，所有对象的 keys 都是字符串(除非对象是 Symbol)。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。</p>
<p>在我们使用括号语法时([]), JavaScript 会解释(或者 unboxes)语句。它首先看到第一个开始括号[并继续前进直到找到结束括号]. 只有这样，它才会计算语句的值。</p>
<p>mouse[bird.size]: 首先计算 bird.size, 得到 size 的值为&rsquo;small'。mouse[&ldquo;small&rdquo;] 返回 true。</p>
<p>然后使用点语法的话，mouse 不包含 bird 这个 key， mouse.bird 返回 undefined。所以在使用点语法 mouse.bird.size 时， 因为 mouse.bird 是 undefined， 变成了 undefined.size 。会抛出 &lsquo;cannot read property &ldquo;size&rdquo; of undefined&rsquo; 的错误。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>6.输出是什么？ 2021-04-04</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">greeting</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Hey!&#39;</span> };
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">d</span>;

<span style="color:#a6e22e">d</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">c</span>;
<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">greeting</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Hello&#39;</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">greeting</span>);
</code></pre></div><ul>
<li>A: Hello</li>
<li>B: undefined</li>
<li>C: ReferenceError</li>
<li>D: TypeError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted --></p>
<p>在 JavaScript 中，当设置两个对象彼此相等时，它们会通过引用进行交互。
首先，变量 c 的值是一个对象，接下来，给 d 分配了一个和 c 对象相同的引用。</p>
<!-- raw HTML omitted -->
<blockquote>
<p>7.输出是什么？ 2021-04-04</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Number(<span style="color:#ae81ff">3</span>);
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">b</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">b</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">c</span>);
</code></pre></div><ul>
<li>A: true false true</li>
<li>B: false false true</li>
<li>C: true false false</li>
<li>D: false true true</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted --></p>
<p>new Number() 是一个内建的函数构造器。它实际上返回的是一个对象。
当使用 == 操作符时，它只检查两者是否拥有相同的值。因为它们的值都是 3，因此返回 true。
当使用 === 操作符时，两者的值以及类型都应该是相同的。new Number() 是一个对象而不是 number，因此返回 false。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>8.输出是什么？ 2021-04-04</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Chameleon</span> {
  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">colorChange</span>(<span style="color:#a6e22e">newColor</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">newColor</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newColor</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">newColor</span>;
  }

  <span style="color:#a6e22e">constructor</span>({ <span style="color:#a6e22e">newColor</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;green&#39;</span> } <span style="color:#f92672">=</span> {}) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">newColor</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newColor</span>;
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">freddie</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Chameleon</span>({ <span style="color:#a6e22e">newColor</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;purple&#39;</span> });
<span style="color:#a6e22e">freddie</span>.<span style="color:#a6e22e">colorChange</span>(<span style="color:#e6db74">&#39;orange&#39;</span>);
</code></pre></div><ul>
<li>A: orange</li>
<li>B: purple</li>
<li>C: green</li>
<li>D: TypeError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted --></p>
<p>colorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用(Chameleon)，并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出 TypeError 错误。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>9.输出是什么？2021-04-05</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">greeting</span>;
<span style="color:#a6e22e">greetign</span> <span style="color:#f92672">=</span> {}; <span style="color:#75715e">// Typo!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">greetign</span>);
</code></pre></div><ul>
<li>A: {}</li>
<li>B: ReferenceError: greetign is not defined</li>
<li>C: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
代码打印出一个空对象，这是因为代码执行后在全局对象创建了一个空对象。当我们将 <code>greeting</code> 写错成 <code>greetign</code> 时,JS 解释器在浏览器上将它看做 gllbal.greetign = {}(或者 window.greetign = {})
为了避免此类问题，可以用 <code>&quot;use strict&quot;</code>来确保声明变量时必须要赋值。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>10.当我们这么做时，会发生什么? 2021-04-06</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bark</span>() {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Woof!&#39;</span>);
}

<span style="color:#a6e22e">bark</span>.<span style="color:#a6e22e">animal</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;dog&#39;</span>;
</code></pre></div><ul>
<li>A: 正常运行</li>
<li>B: SyntaxError. 你不能通过这种方式给函数增加属性。</li>
<li>C: undefined</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
函数 bark 也是特殊的对象。函数是一个拥有属性的对象，并且属性也可以被调用。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>11.输出是什么? 2021-04-07</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Person</span>(<span style="color:#a6e22e">firstName</span>, <span style="color:#a6e22e">lastName</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstName</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lastName</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">member</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>(<span style="color:#e6db74">&#39;Lydia&#39;</span>, <span style="color:#e6db74">&#39;Hallie&#39;</span>);
<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">getFullName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstName</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastName</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
};

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">member</span>.<span style="color:#a6e22e">getFullName</span>());
</code></pre></div><ul>
<li>A: TypeError</li>
<li>B: SyntaxError</li>
<li>C: Lydia Hallie</li>
<li>D: undefined undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
不能像常规对象那样，给构造函数添加属性。如果想一次性给所有实例添加特性，就应该使用原型。即如下方式:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">getFullName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstName</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastName</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
};
</code></pre></div><p>这样才会使 member.getFullName() 起作用。如果将方法添加到构造函数本身，将浪费大量内存空间，因为不是所有 Person 实例都需要这个方法。相反，如果只将它添加到原型汇总，那么它只存在于内存的一个位置，并且所有实例仍然可以访问它。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>12.输出是什么? 2021-04-07</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Person</span>(<span style="color:#a6e22e">firstName</span>, <span style="color:#a6e22e">lastName</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstName</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lastName</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lydia</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>(<span style="color:#e6db74">&#39;Lydia&#39;</span>, <span style="color:#e6db74">&#39;Hallie&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sarah</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Person</span>(<span style="color:#e6db74">&#39;Sarah&#39;</span>, <span style="color:#e6db74">&#39;Smith&#39;</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">lydia</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sarah</span>);
</code></pre></div><ul>
<li>A: Person {firstName: &ldquo;Lydia&rdquo;, lastName: &ldquo;Hallie&rdquo;} and undefined</li>
<li>B: Person {firstName: &ldquo;Lydia&rdquo;, lastName: &ldquo;Hallie&rdquo;} and Person {firstName: &ldquo;Sarah&rdquo;, lastName: &ldquo;Smith&rdquo;}</li>
<li>C: Person {firstName: &ldquo;Lydia&rdquo;, lastName: &ldquo;Hallie&rdquo;} and {}</li>
<li>D: Person {firstName: &ldquo;Lydia&rdquo;, lastName: &ldquo;Hallie&rdquo;} and ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
对于 sarah, 我们没有使用 <code>new</code> 关键字。当使用 <code>new</code> 时， <code>this</code> 引用我们创建的空对象。当未使用 <code>new</code> 时, <code>this</code> 引用的是全局对象(global object)。
我们说 <code>this.firstName</code> 等于 &ldquo;Sarah&rdquo;, 并且 <code>this.lastName</code> 等于 <code>Smith</code>。实际上我们做的是，定义了 <code>global.firstName = 'Sarah'</code> 和 <code>global.lastName = 'Smith'</code>。而 <code>sarah</code> 本身是 <code>undefined</code>。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>13.事件传播的三个阶段是什么? 2021-04-07</p>
</blockquote>
<ul>
<li>A: Target &gt; Capturing &gt; Bubbling</li>
<li>B: Bubbling &gt; Target &gt; Capturing</li>
<li>C: Target &gt; Bubbling &gt; Capturing</li>
<li>D: Capturing &gt; Target &gt; Bubbling</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
在 <code>捕获(capturing)</code>阶段中，事件从祖先元素向下传播到目标元素。当事件达到<code>目标(target)</code>元素后，<code>冒泡(bubbling)</code>才开始。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>14.所有对象都有原型? 2021-04-08</p>
</blockquote>
<ul>
<li>A: 对</li>
<li>B: 错</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
除了 <code>基本对象（base object）</code> ,所有对象都有原型。基本对象可以访问一些方法和属性，比如 <code>.toString</code>。这就是为什么你可以使用内置的 JavaScript 方法! 所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于使用。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>15.事件传播的三个阶段是什么? 2021-04-08</p>
</blockquote>
<ul>
<li>A: Target &gt; Capturing &gt; Bubbling</li>
<li>B: Bubbling &gt; Target &gt; Capturing</li>
<li>C: Target &gt; Bubbling &gt; Capturing</li>
<li>D: Capturing &gt; Target &gt; Bubbling</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
在 <code>捕获(capturing)</code>阶段中，事件从祖先元素向下传播到目标元素。当事件达到<code>目标(target)</code>元素后，<code>冒泡(bubbling)</code>才开始。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>16.输出是什么? 2021-04-08</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
}
<span style="color:#a6e22e">sum</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;2&#39;</span>);
</code></pre></div><ul>
<li>A: NaN</li>
<li>B: TypeError</li>
<li>C: &ldquo;12&rdquo;</li>
<li>D: 3</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
JavaScript 是一种动态类型语言：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为隐式类型转换（implicit type coercion）。Coercion 是指将一种类型转换为另一种类型。</p>
<p>在本例中，JavaScript 将数字 1 转换为字符串，以便函数有意义并返回一个值。在数字类型（1）和字符串类型（&lsquo;2&rsquo;）相加时，该数字被视为字符串。我们可以连接字符串，比如 &ldquo;Hello&rdquo; + &ldquo;World&rdquo;，这里发生的是 &ldquo;1&rdquo; + &ldquo;2&rdquo;，它返回 &ldquo;12&rdquo;。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>17.输出是什么? 2021-04-08</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">funciton</span> <span style="color:#a6e22e">getPersonInfo</span>(<span style="color:#a6e22e">one</span>, <span style="color:#a6e22e">two</span>, <span style="color:#a6e22e">three</span>) {
  <span style="color:#a6e22e">consle</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">one</span>);
  <span style="color:#a6e22e">consle</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">two</span>);
  <span style="color:#a6e22e">consle</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">three</span>);
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lydia&#39;</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;

<span style="color:#a6e22e">getPersonInfo</span><span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">person</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">age</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> years old`</span>
</code></pre></div><ul>
<li>A: &ldquo;Lydia&rdquo; 21 [&quot;&quot;, &quot; is &ldquo;, &quot; years old&rdquo;]</li>
<li>B: [&quot;&quot;, &quot; is &ldquo;, &quot; years old&rdquo;] &ldquo;Lydia&rdquo; 21</li>
<li>C: &ldquo;Lydia&rdquo; [&quot;&quot;, &quot; is &ldquo;, &quot; years old&rdquo;] 21</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>18.输出是什么? 2021-04-09</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">funciton</span> <span style="color:#a6e22e">checkAge</span>(<span style="color:#a6e22e">data</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">data</span> <span style="color:#f92672">===</span> {<span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">18</span>}) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;You are a man!&#39;</span>);
  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">data</span> <span style="color:#f92672">==</span> {<span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">18</span>}) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;You are still a man.&#39;</span>);
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Oops...I can&#39;</span><span style="color:#a6e22e">t</span> <span style="color:#a6e22e">guess</span> <span style="color:#a6e22e">your</span> <span style="color:#a6e22e">age</span><span style="color:#960050;background-color:#1e0010">&#39;</span>)
  }
}

<span style="color:#a6e22e">checkAge</span>({<span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">18</span>});
</code></pre></div><ul>
<li>A: You are a man!</li>
<li>B: You are still a man.</li>
<li>C: Oops&hellip;I can&rsquo;t guess your age</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
在测试相等性时，基本类型通过它们的值(value)进行比较，而对象通过它们的引用(reference) 进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。</p>
<p>题目中我们正在比较的两个对象是不同一个引用: 作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。
这也是{ age: 18 } === { age: 18 } 和 { age: 18 } == { age: 18 } 都返回 false 的原因。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>19.输出是什么? 2021-04-09</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">funciton</span> <span style="color:#a6e22e">getAge</span>(...<span style="color:#a6e22e">args</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">args</span>)
}

<span style="color:#a6e22e">getAge</span>(<span style="color:#ae81ff">27</span>);
</code></pre></div><ul>
<li>A: &ldquo;number&rdquo;</li>
<li>B: &ldquo;array&rdquo;</li>
<li>C: &ldquo;object&rdquo;</li>
<li>D: &ldquo;NaN&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
扩展运算符(&hellip;args)会返回实参组成的数组。而数组是对象，因此 typeof args 返回 &ldquo;object&rdquo;。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>20.输出是什么? 2021-04-09</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getAge</span>() {
  <span style="color:#e6db74">&#39;use strict&#39;</span>;
  <span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">age</span>);
}

<span style="color:#a6e22e">getAge</span>();
</code></pre></div><ul>
<li>A: 21</li>
<li>B: undefined</li>
<li>C: ReferenceError</li>
<li>D: TypeError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
使用 <code>&quot;use strict&quot;</code>,你可以确保不会意外地声明全局变量。我们从来没有声明变量 age，因为我们使用<code>&quot;use strict&quot;</code>,它将抛出一个引用错误。如果我们不使用<code>&quot;use strict&quot;</code>,它就会工作，因为属性 <code>age</code> 会被添加到全局对象中。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>21.输出是什么? 2021-04-10</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> eval(<span style="color:#e6db74">&#39;10*10+5&#39;</span>);
</code></pre></div><ul>
<li>A: 105</li>
<li>B: &ldquo;105&rdquo;</li>
<li>C: TypeError</li>
<li>D: &ldquo;10*10+5&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
代码以字符串形式传递进来，eval 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 10 * 10 + 5. 这将返回数字 105。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>22.cool_secret 可以访问多长时间? 2021-04-10</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#39;cool_secret&#39;</span>, <span style="color:#ae81ff">123</span>);
</code></pre></div><ul>
<li>A: 永远，数据不会丢失。</li>
<li>B: 当用户关掉标签页时。</li>
<li>C: 当用户关掉整个浏览器，而不只是关掉标签页。</li>
<li>D: 当用户关闭电脑时。</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
关闭 tab 标签页 后，sessionStorage 存储的数据才会删除。
如果使用 localStorage，那么数据将永远在那里，除非调用 localStorage.clear()。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>23.输出是什么? 2021-04-10</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</code></pre></div><ul>
<li>A: 8</li>
<li>B: 10</li>
<li>C: SyntaxError</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
使用 var 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。
你不能使用 let 或 const 来实现这一点。因为它们是块作用域的。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>24.输出是什么? 2021-04-11</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;c&#39;</span> };
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">set</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>]);

<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#39;1&#39;</span>);
<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">has</span>(<span style="color:#e6db74">&#39;1&#39;</span>);
<span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">has</span>(<span style="color:#ae81ff">1</span>);
</code></pre></div><ul>
<li>A: false true false true</li>
<li>B: false true true true</li>
<li>C: true true false true</li>
<li>D: true true true true</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
所有对象的键(不包括 Symbol) 在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 obj.hasOwnproperty(&lsquo;1&rsquo;) 也返回 true。
对于集合，它不是这样工作的。在我们的集合中没有'1': set.has(&lsquo;1&rsquo;) 返回 false。它有数字类型为 1, set.has(1) 返回 true。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>25.输出是什么? 2021-04-11</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">a</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;one&#39;</span>, <span style="color:#a6e22e">b</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;two&#39;</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;three&#39;</span> };
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">obj</span>);
</code></pre></div><ul>
<li>A: { a: &ldquo;one&rdquo;, b: &ldquo;two&rdquo; }</li>
<li>B: { b: &ldquo;two&rdquo;, a: &ldquo;three&rdquo; }</li>
<li>C: { a: &ldquo;three&rdquo;, b: &ldquo;two&rdquo; }</li>
<li>D: SyntaxError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
如果对象中有 2 个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>26.JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。 2021-04-11</p>
</blockquote>
<ul>
<li>A: 对</li>
<li>B: 错</li>
<li>C: 看情况</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>27.输出是什么? 2021-04-11</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">3</span>) <span style="color:#66d9ef">continue</span>;
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>);
}
</code></pre></div><ul>
<li>A: 1 2</li>
<li>B: 1 2 3</li>
<li>C: 1 2 4</li>
<li>D: 1 3 4</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
如果某个条件返回 true，则 continue 语句跳过本次迭代。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>28.输出是什么？ 2021-04-12</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">String.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">giveLydiaPizza</span> <span style="color:#f92672">=</span> () =&gt; {
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;Just give Lydia pizza already!&#39;</span>;
};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lydia&#39;</span>;

<span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">giveLydiaPizza</span>();
</code></pre></div><ul>
<li>A: &ldquo;Just give Lydia pizza already!&rdquo;</li>
<li>B: TypeError: not a function</li>
<li>C: SyntaxError</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
String 是内置的构造函数，我们可以向它添加属性。我们只是在它的原型中添加了一个方法。基本类型字符串被自动转换成字符串对象，由字符串原型函数生成。因此，所有 String(string 对象) 都可以访问该方法!</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>29.输出是什么 2021-04-12</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> {};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;b&#39;</span> };
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">ley</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;c&#39;</span> };

<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">b</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;
<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">c</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">456</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">b</span>]);
</code></pre></div><ul>
<li>A: 123</li>
<li>B: 456</li>
<li>C: undefined</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
对象的键被自动转换为字符串。我们试图将一个对象 b 设置为对象 a 的键，且相应的值为 123。</p>
<p>然而，当字符串化一个对象时，它会变成 &ldquo;[object Object]&quot;。因此这里说的是，a[&quot;[object Object]&quot;] = 123。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[&quot;[object Object]&quot;] = 456。</p>
<p>然后，我们打印 a[b]，也就是 a[&quot;[object Object]&quot;]。之前刚设置为 456，因此返回的是 456。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>30.输出是什么? 2021-04-13</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">foo</span> <span style="color:#f92672">=</span> () =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;First&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bar</span> <span style="color:#f92672">=</span> () =&gt; <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Second&#39;</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">barz</span> <span style="color:#f92672">=</span> () =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Third&#39;</span>);

<span style="color:#a6e22e">bar</span>();
<span style="color:#a6e22e">foo</span>();
<span style="color:#a6e22e">baz</span>();
</code></pre></div><ul>
<li>A: First Second Third</li>
<li>B: First Third Second</li>
<li>C: Second First Third</li>
<li>D: Second Third First</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
这里有一个 setTimeout 函数，并首先调用它。然而，它是最后才输出 console 的。
因为在浏览器中，不仅有运行时引擎，还有一个叫 WebAPI 的东西。WebAPI 提供了 setTimeout 函数，也包含其他的，例如 DOM。</p>
<p>将 callback 推送到 WebAPI 后，setTimeout 函数本身(不是回调！) 将从栈中弹出。
步骤：</p>
<ol>
<li>foo 被调用，打印 &ldquo;First&rdquo;</li>
<li>foo 从栈中弹出, baz 被调用，打印 &ldquo;Third&rdquo;</li>
<li>WebAPI 不能随时向栈内添加内容。相反它将回调函数推到名为 queue 的地方。</li>
<li>这就是事件循环开始工作的地方。一个 事件循环 查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。</li>
<li>bar 被调用。打印 &ldquo;Second&rdquo;, 然后被栈弹出
<!-- raw HTML omitted --></li>
</ol>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>31.当点击按钮时，event.target 是什么？ 2021-04-13</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">onclick</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;console.log(&#39;first div&#39;)&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">onclick</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;console.log(&#39;second div&#39;)&#34;</span>&gt;
    &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">onclick</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;console.log(&#39;button&#39;)&#34;</span>&gt;Click!&lt;/<span style="color:#f92672">button</span>&gt;
  &lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><ul>
<li>A: Outer div</li>
<li>B: Inner div</li>
<li>C: button</li>
<li>D: 一个包含所有嵌套元素的数组。</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
导致事件的最深嵌套的元素是事件的 target。 可以通过 event.stopPropagation 来停止冒泡。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>32.当单击该段落时，日志输出是什么？ 2021-04-13</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">onclick</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;console.log(&#39;div&#39;)&#34;</span><span style="color:#f92672">&gt;</span>
  <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span> <span style="color:#a6e22e">onclick</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;console.log(&#39;p&#39;)&#34;</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Click</span> <span style="color:#a6e22e">here</span><span style="color:#f92672">!&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;</span>
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/div&gt;</span>
</code></pre></div><ul>
<li>A: p div</li>
<li>B: div p</li>
<li>C: p</li>
<li>D: div</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
当点击 p 标签，我们会看到两个输出日志: p 和 div。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行(除非将 useCapture 设置为 true)。它从嵌套最深的元素向外传播。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>33.输出是什么？ 2021-04-13</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lydia&#39;</span> };
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHi</span>(<span style="color:#a6e22e">age</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">age</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
}

<span style="color:#a6e22e">sayHi</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">person</span>, <span style="color:#ae81ff">21</span>);
<span style="color:#a6e22e">sayHi</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">person</span>, <span style="color:#ae81ff">21</span>);
</code></pre></div><ul>
<li>A: undefined is 21 Lydia is 21</li>
<li>B: function function</li>
<li>C: Lydia is 21 Lydia is 21</li>
<li>D: Lydia is 21 function</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
使用这两种方法，我们都可以传递我们希望 this 关键字引用的对象。但是，.call 是立即执行的。
.bind 返回函数的副本，但带有绑定上下文！它不是立即执行的。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>34.输出是什么？ 2021-04-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SayHi</span>() {
  <span style="color:#66d9ef">return</span> (() =&gt; <span style="color:#ae81ff">0</span>)();
}

<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">SayHi</span>();
</code></pre></div><ul>
<li>A: &ldquo;object&rdquo;</li>
<li>B: &ldquo;number&rdquo;</li>
<li>C: &ldquo;function&rdquo;</li>
<li>D: &ldquo;undefined&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
SayHi 方法返回的是立即执行函数(IIFE)的返回值。此立即执行函数的返回值是 0，类型是 number。
参考：只有 7 种内置类型：null, undefined, boolean, number, string, object, symbol, bigint。 fucntion 不是一种类型，函数是对象，他的类型是 object。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>35.下面哪些值是 falsy？ 2021-04-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">a</span>.<span style="color:#ae81ff">0</span>
<span style="color:#a6e22e">b</span>.<span style="color:#66d9ef">new</span> Number(<span style="color:#ae81ff">0</span>)
<span style="color:#a6e22e">c</span>.(<span style="color:#e6db74">&#39;&#39;</span>)
<span style="color:#a6e22e">d</span>.(<span style="color:#e6db74">&#39; &#39;</span>)
<span style="color:#a6e22e">e</span>.<span style="color:#66d9ef">new</span> Boolean(<span style="color:#66d9ef">false</span>)
<span style="color:#a6e22e">f</span>.<span style="color:#66d9ef">undefined</span>
</code></pre></div><ul>
<li>A: a,c,f</li>
<li>B: a,b,c,e,f</li>
<li>C: a,b,e,f</li>
<li>D: all</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
只有 6 种 falsy 值: undefined，null，NaN，0，''(empty string)，false。Function 构造函数，比如 new Number 和 new Boolean，是 truthy。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>36.输出是什么？ 2021-04-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#66d9ef">typeof</span> <span style="color:#ae81ff">1</span>);
</code></pre></div><ul>
<li>A: &ldquo;number&rdquo;</li>
<li>B: &ldquo;string&rdquo;</li>
<li>C: &ldquo;object&rdquo;</li>
<li>D: &ldquo;undefined&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
typeof 1 返回 &ldquo;number&rdquo;。typeof &ldquo;number&rdquo; 返回&quot;string&rdquo;</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>37.输出是什么？ 2021-04-15</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
<span style="color:#a6e22e">numbers</span>[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">numbers</span>);
</code></pre></div><ul>
<li>A: [1, 2, 3, null x 7, 11]</li>
<li>B: [1, 2, 3, 11]</li>
<li>C: [1, 2, 3, empty x 7, 11]</li>
<li>D: SyntaxError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
当为数组设置超过数组长度的值的时候，JavaScript 会创建名为&quot;empty slots&quot;的东西。它们的值实际上是 undefined。你会看到以下场景:
Chrome:[1, 2, 3, empty x 7, 11]
Node: [ 1, 2, 3, &lt;7 empty items&gt;, 11 ]
这取决于运行环境的不同</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>38.输出是什么？ 2021-04-15</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">(() =&gt; {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>;
  <span style="color:#66d9ef">try</span> {
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error();
  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">x</span>) {
    (<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>), (<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>);
  }
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">y</span>);
})();
</code></pre></div><ul>
<li>A: 1 undefined 2</li>
<li>B: undefined undefined undefined</li>
<li>C: 1 1 2</li>
<li>D: 1 undefined undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
catch 代码块接收参数 x。当我们传递参数时，这与之前定义的变量 x 不同。这个 x 是属于 catch 块级作用域的。
然后，我们将块级作用域中的变量赋值为 1，同时也设置了变量 y 的值。现在，我们打印块级作用域中的变量 x，值为 1.
catch 块之外的变量 x 的值仍为 undefined，y 的值为 2.当我们在 catch 块之外执行 console.log(x)时，返回 undefined，y 返回 2。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>39.JavaScript 中的一切都是？ 2021-04-15</p>
</blockquote>
<ul>
<li>A: 基本类型与对象</li>
<li>B: 函数与对象</li>
<li>C: 只有对象</li>
<li>D: 数字与对象</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
基本类型包括: boolean, number, string, symble, bigint, null, undefined。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>40.输出是什么？ 2021-04-15</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">[
  [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
  [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>],
].<span style="color:#a6e22e">reduce</span>(
  (<span style="color:#a6e22e">acc</span>, <span style="color:#a6e22e">cur</span>) =&gt; {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">acc</span>.<span style="color:#a6e22e">concat</span>(<span style="color:#a6e22e">cur</span>);
  },
  [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>]
);
</code></pre></div><ul>
<li>A: [0, 1, 2, 3, 1, 2]</li>
<li>B: [6, 1, 2]</li>
<li>C: [1, 2, 0, 1, 2, 3]</li>
<li>D: [1, 2, 6]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
[1, 2]是初始值。初始值将会作为首次调用时第一个参数 acc 的值。在第一次执行时，acc 的值是[1, 2], cur 的值是[0, 1]。合并它们，结果为[1, 2, 0, 1]。第二次执行，acc 的值是[1, 2, 0, 1]，cur 的值是[2, 3]。合并它们，最终结果为[1, 2, 0, 1, 2, 3]</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>41.输出是什么？ 2021-04-16</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#f92672">!!</span><span style="color:#66d9ef">null</span>;
<span style="color:#f92672">!!</span><span style="color:#e6db74">&#39;&#39;</span>;
<span style="color:#f92672">!!</span><span style="color:#ae81ff">1</span>;
</code></pre></div><ul>
<li>A: false true false</li>
<li>B: false false true</li>
<li>C: false true true</li>
<li>D: true true false</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
null 是 falsy。!null 的值是 true。!true 的值是 false。
&quot;&quot; 是 falsy。!&ldquo;&ldquo;的值是 true。!true 的值是 false。
1 是 truthy。!1 的值是 false。!false 的值是 true。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>42.setInterval 方法的返回值是什么？ 2021-04-16</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">setInterval</span>(() =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Hi&#39;</span>), <span style="color:#ae81ff">1000</span>);
</code></pre></div><ul>
<li>A: 一个唯一的 id</li>
<li>B: 该方法指定的毫秒数</li>
<li>C: 传递的函数</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
setInterval 返回一个唯一的 id。此 id 可被用于 clearInterval 函数来取消定时。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>43.输出是什么？ 2021-04-16</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">[...<span style="color:#e6db74">&#39;Lydia&#39;</span>];
</code></pre></div><ul>
<li>A: [&ldquo;L&rdquo;, &ldquo;y&rdquo;, &ldquo;d&rdquo;, &ldquo;i&rdquo;, &ldquo;a&rdquo;]</li>
<li>B: [&ldquo;Lydia&rdquo;]</li>
<li>C: [[], &ldquo;Lydia&rdquo;]</li>
<li>D: [[&ldquo;L&rdquo;, &ldquo;y&rdquo;, &ldquo;d&rdquo;, &ldquo;i&rdquo;, &ldquo;a&rdquo;]]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
string 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>44.输出是什么？ 2021-04-17</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">generator</span>(<span style="color:#a6e22e">i</span>) {
  <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">i</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">gen</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generator</span>(<span style="color:#ae81ff">10</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span>);
</code></pre></div><ul>
<li>A: [0, 10], [10, 20]</li>
<li>B: 20, 20</li>
<li>C: 10, 20</li>
<li>D: 0, 10 and 10, 20</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
一般的函数在执行之后是不能中途停下的。但是，生成器函数却可以中途“停下”，之后可以再从停下的地方继续。当生成器遇到 yield 关键字的时候，会生成 yield 后面的值。注意，生成器在这种情况下不 返回 (return )值，而是 生成 (yield)值。</p>
<p>首先，我们用 10 作为参数 i 来初始化生成器函数。然后使用 next()方法一步步执行生成器。第一次执行生成器的时候，i 的值为 10，遇到第一个 yield 关键字，它要生成 i 的值。此时，生成器“暂停”，生成了 10。</p>
<p>然后，我们再执行 next()方法。生成器会从刚才暂停的地方继续，这个时候 i 还是 10。于是我们走到了第二个 yield 关键字处，这时候需要生成的值是 i*2，i 为 10，那么此时生成的值便是 20。所以这道题的最终结果是 10,20。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>45.输出是什么？ 2021-04-17</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">firstPromise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">rej</span>) =&gt; {
  <span style="color:#a6e22e">setTimeout</span>(<span style="color:#a6e22e">res</span>, <span style="color:#ae81ff">500</span>, <span style="color:#e6db74">&#39;one&#39;</span>);
});
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">secondPromise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">rej</span>) =&gt; {
  <span style="color:#a6e22e">setTimeout</span>(<span style="color:#a6e22e">res</span>, <span style="color:#ae81ff">100</span>, <span style="color:#e6db74">&#39;two&#39;</span>);
});

Promise.<span style="color:#a6e22e">race</span>([<span style="color:#a6e22e">firstPromise</span>, <span style="color:#a6e22e">secondPromise</span>]).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">res</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>));
</code></pre></div><ul>
<li>A: &ldquo;one&rdquo;</li>
<li>B: &ldquo;two&rdquo;</li>
<li>C: &ldquo;two&rdquo; &ldquo;one&rdquo;</li>
<li>D: &ldquo;one&rdquo; &ldquo;two&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
当我们向 Promise.race 方法中传入多个 Promise 时，会进行 优先 解析。在这个例子中，我们用 setTimeout 给 firstPromise 和 secondPromise 分别设定了 500ms 和 100ms 的定时器。这意味着 secondPromise 会首先解析出字符串 two。那么此时 res 参数即为 two，是为输出结果。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>46.输出是什么？ 2021-04-17</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lydia&#39;</span> };
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">members</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">person</span>];
<span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">members</span>);
</code></pre></div><ul>
<li>A: null</li>
<li>B: [null]</li>
<li>C: [{}]</li>
<li>D: [{ name: &ldquo;Lydia&rdquo; }]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
首先我们声明了一个拥有 name 属性的对象 person</p>
<p>然后我们又声明了一个变量 members. 将首个元素赋值为变量 person。 当设置两个对象彼此相等时，它们会通过 引用 进行交互。但是当你将引用从一个变量分配至另一个变量时，其实只是执行了一个 复制 操作。（注意一点，他们的引用 并不相同!）</p>
<p>接下来我们让 person 等于 null。</p>
<p>我们没有修改数组第一个元素的值，而只是修改了变量 person 的值,因为元素（复制而来）的引用与 person 不同。members 的第一个元素仍然保持着对原始对象的引用。当我们输出 members 数组时，第一个元素会将引用的对象打印出来。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>47.输出是什么？ 2021-04-18</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lydia&#39;</span>,
  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">21</span>,
};

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">person</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>);
}
</code></pre></div><ul>
<li>A: { name: &ldquo;Lydia&rdquo; }, { age: 21 }</li>
<li>B: &ldquo;name&rdquo;, &ldquo;age&rdquo;</li>
<li>C: &ldquo;Lydia&rdquo;, 21</li>
<li>D: [&ldquo;name&rdquo;, &ldquo;Lydia&rdquo;], [&ldquo;age&rdquo;, 21]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
在 for-in 循环中,我们可以通过对象的 key 来进行迭代,也就是这里的 name 和 age。在底层，对象的 key 都是字符串（如果他们不是 Symbol 的话）。在每次循环中，我们将 item 设定为当前遍历到的 key.所以一开始，item 是 name，之后 item 输出的则是 age。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>48.输出是什么？ 2021-04-18</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;5&#39;</span>);
</code></pre></div><ul>
<li>A: &ldquo;345&rdquo;</li>
<li>B: &ldquo;75&rdquo;</li>
<li>C: 12</li>
<li>D: &ldquo;12&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
当所有运算符的 优先级 相同时，计算表达式需要确定运算符的结合顺序，即从右到左还是从左往右。在这个例子中，我们只有一类运算符+，对于加法来说，结合顺序就是从左到右。</p>
<p>3 + 4 首先计算，得到数字 7.</p>
<p>由于类型的强制转换，7 + &lsquo;5&rsquo;的结果是&quot;75&rdquo;. JavaScript 将 7 转换成了字符串，可以参考问题 15.我们可以用+号把两个字符串连接起来。 &ldquo;7&rdquo; + &ldquo;5&rdquo; 就得到了&quot;75&rdquo;.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>49.num 的值是什么？ 2021-04-18</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">=</span> parseInt(<span style="color:#e6db74">&#39;7*6&#39;</span>, <span style="color:#ae81ff">10</span>);
</code></pre></div><ul>
<li>A: 42</li>
<li>B: &ldquo;42&rdquo;</li>
<li>C: 7</li>
<li>D: NaN</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
只返回了字符串中第一个字母. 设定了 进制 后 (也就是第二个参数，指定需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),parseInt 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。</p>
<p>*就是不合法的数字字符。所以只解析到&quot;7&quot;，并将其解析为十进制的 7. num 的值即为 7.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>50.输出是什么？ 2021-04-18</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>].<span style="color:#a6e22e">map</span>((<span style="color:#a6e22e">num</span>) =&gt; {
  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;number&#39;</span>) <span style="color:#66d9ef">return</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
});
</code></pre></div><ul>
<li>A: []</li>
<li>B: [null, null, null]</li>
<li>C: [undefined, undefined, undefined]</li>
<li>D: [ 3 x empty ]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
对数组进行映射的时候,num 就是当前循环到的元素. 在这个例子中，所有的映射都是 number 类型，所以 if 中的判断 typeof num === &ldquo;number&quot;结果都是 true.map 函数创建了新数组并且将函数的返回值插入数组。</p>
<p>但是，没有任何值返回。当函数没有返回任何值时，即默认返回 undefined.对数组中的每一个元素来说，函数块都得到了这个返回值，所以结果中每一个元素都是 undefined.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>51.输出是什么？ 2021-04-19</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getInfo</span>(<span style="color:#a6e22e">member</span>, <span style="color:#a6e22e">year</span>) {
  (<span style="color:#a6e22e">member</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lydia&#39;</span>), (<span style="color:#a6e22e">year</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1998&#39;</span>);
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Sarah&#39;</span> };
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">birthYear</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1997&#39;</span>;

<span style="color:#a6e22e">getInfo</span>(<span style="color:#a6e22e">person</span>, <span style="color:#a6e22e">birthYear</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>, <span style="color:#a6e22e">birthYear</span>);
</code></pre></div><ul>
<li>A: { name: &ldquo;Lydia&rdquo; }, &ldquo;1997&rdquo;</li>
<li>B: { name: &ldquo;Sarah&rdquo; }, &ldquo;1998&rdquo;</li>
<li>C: { name: &ldquo;Lydia&rdquo; }, &ldquo;1998&rdquo;</li>
<li>D: { name: &ldquo;Sarah&rdquo; }, &ldquo;1997&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
普通参数都是 值 传递的，而对象则不同，是 引用 传递。所以说，birthYear 是值传递，因为他是个字符串而不是对象。当我们对参数进行值传递时，会创建一份该值的 复制 。（可以参考问题 46）</p>
<p>变量 birthYear 有一个对&quot;1997&quot;的引用，而传入的参数也有一个对&quot;1997&quot;的引用，但二者的引用并不相同。当我们通过给 year 赋值&quot;1998&quot;来更新 year 的值的时候我们只是更新了 year（的引用）。此时 birthYear 仍然是&quot;1997&rdquo;.</p>
<p>而 person 是个对象。参数 member 引用与之 相同的 对象。当我们修改 member 所引用对象的属性时,person 的相应属性也被修改了,因为他们引用了相同的对象. person 的 name 属性也变成了 &ldquo;Lydia&rdquo;.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>52.输出是什么？ 2021-04-19</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greeting</span>() {
  <span style="color:#a6e22e">thow</span> <span style="color:#e6db74">&#34;Hello world&#34;</span>;
}
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHi</span>() {
  <span style="color:#66d9ef">try</span> {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">greeting</span>();
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;It worked!&#34;</span>, <span style="color:#a6e22e">data</span>);
  } <span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Oh no an error:&#34;</span>, <span style="color:#a6e22e">e</span>);
  }
}
<span style="color:#a6e22e">sayHi</span>();
</code></pre></div><ul>
<li>A: &ldquo;It worked! Hello world!&rdquo;</li>
<li>B: &ldquo;Oh no an error: undefined</li>
<li>C: SyntaxError: can only throw Error objects</li>
<li>D: &ldquo;Oh no an error: Hello world!</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
通过 throw 语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。异常可以是一个字符串, 一个 数字, 一个 布尔类型 或者是一个 对象。在本例中，我们的异常是字符串&rsquo;Hello world&rsquo;.</p>
<p>通过 catch 语句，我们可以设定当 try 语句块中抛出异常后应该做什么处理。在本例中抛出的异常是字符串&rsquo;Hello world'. e 就是这个字符串，因此被输出。最终结果就是&rsquo;Oh an error: Hello world'.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>53.输出是什么？ 2021-04-19</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Car</span>() {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">make</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lamborghini&#39;</span>;
  <span style="color:#66d9ef">return</span> { <span style="color:#a6e22e">make</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Maserati&#39;</span> };
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myCar</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Car</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">myCar</span>.<span style="color:#a6e22e">make</span>);
</code></pre></div><ul>
<li>A: &ldquo;Lamborghini&rdquo;</li>
<li>B: &ldquo;Maserati&rdquo;</li>
<li>C: ReferenceError</li>
<li>D: TypeError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
返回属性的时候，属性的值等于 返回的 值，而不是构造函数中设定的值。我们返回了字符串 &ldquo;Maserati&rdquo;，所以 myCar.make 等于&quot;Maserati&rdquo;.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>54.输出是什么？ 2021-04-20</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">(() =&gt; {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>);
})();

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">x</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">y</span>);
</code></pre></div><ul>
<li>A: &ldquo;undefined&rdquo;, &ldquo;number&rdquo;</li>
<li>B: number&rdquo;, &ldquo;number&rdquo;</li>
<li>C: object&quot;, &ldquo;number&rdquo;</li>
<li>D: &ldquo;number&rdquo;, &ldquo;undefined&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
let x = y = 10; 是下面这个表达式的缩写：
y = 10;
let x = y;
然后我们声明了变量 x 等于 y,也是 10.但变量是使用 let 声明的，它只作用于 块级作用域, 仅在声明它的块中有效；就是案例中的立即调用表达式(IIFE)。使用 typeof 操作符时, 操作值 x 没有被定义：因为我们在 x 声明块的外部，无法调用它。这就意味着 x 未定义。未分配或是未声明的变量类型为&quot;undefined&quot;. console.log(typeof x)返回&quot;undefined&quot;.</p>
<p>而我们创建了全局变量 y，并且设定 y 等于 10.这个值在我们的代码各处都访问的到。 y 已经被定义了，而且有一个&quot;number&quot;类型的值。 console.log(typeof y)返回&quot;number&quot;.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>55.输出是什么？ 2021-04-20</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
  }
}
<span style="color:#a6e22e">Dog</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">bark</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Woof, I am </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pet</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Dog</span>(<span style="color:#e6db74">&#39;Mara&#39;</span>);
<span style="color:#a6e22e">pet</span>.<span style="color:#a6e22e">bark</span>();
<span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">Dog</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">bark</span>;
<span style="color:#a6e22e">pet</span>.<span style="color:#a6e22e">bark</span>();
</code></pre></div><ul>
<li>A: &ldquo;Woof I am Mara&rdquo;, TypeError</li>
<li>B: &ldquo;Woof I am Mara&rdquo;,&ldquo;Woof I am Mara&rdquo;</li>
<li>C: &ldquo;Woof I am Mara&rdquo;, undefined</li>
<li>D: TypeError, TypeError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
我们可以用 delete 关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了。在本例中，函数 bark 在执行了 delete Dog.prototype.bark 后不可用, 然而后面的代码还在调用它。</p>
<p>当我们尝试调用一个不存在的函数时 TypeError 异常会被抛出。在本例中就是 TypeError: pet.bark is not a function，因为 pet.bark 是 undefined.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>56.输出是什么？ 2021-04-20</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>].<span style="color:#a6e22e">map</span>((<span style="color:#a6e22e">num</span>) =&gt; {
  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;number&#39;</span>) <span style="color:#66d9ef">return</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
});
</code></pre></div><ul>
<li>A: []</li>
<li>B: [null, null, null]</li>
<li>C: [undefined, undefined, undefined]</li>
<li>D: [ 3 x empty ]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
对数组进行映射的时候,num 就是当前循环到的元素. 在这个例子中，所有的映射都是 number 类型，所以 if 中的判断 typeof num === &ldquo;number&quot;结果都是 true.map 函数创建了新数组并且将函数的返回值插入数组。</p>
<p>但是，没有任何值返回。当函数没有返回任何值时，即默认返回 undefined.对数组中的每一个元素来说，函数块都得到了这个返回值，所以结果中每一个元素都是 undefined.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>57.输出是什么？ 2021-04-21</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// counter.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#a6e22e">counter</span>;

<span style="color:#75715e">// index.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">myCounter</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./counter.js&#39;</span>;

<span style="color:#a6e22e">myCounter</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">myCounter</span>);
</code></pre></div><ul>
<li>A: 10</li>
<li>B: 11</li>
<li>C: Error</li>
<li>D: NaN</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
引入的模块是 只读 的: 你不能修改引入的模块。只有导出他们的模块才能修改其值。</p>
<p>当我们给 myCounter 增加一个值的时候会抛出一个异常： myCounter 是只读的，不能被修改。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>58.输出是什么？ 2021-04-21</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lydia&#39;</span>;
<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">name</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">age</span>);
</code></pre></div><ul>
<li>A: false, true</li>
<li>B: &ldquo;Lydia&rdquo;, 21</li>
<li>C: true, true</li>
<li>D: undefined, undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
delete 操作符返回一个布尔值： true 指删除成功，否则返回 false. 但是通过 var, const 或 let 关键字声明的变量无法用 delete 操作符来删除。</p>
<p>name 变量由 const 关键字声明，所以删除不成功:返回 false. 而我们设定 age 等于 21 时,我们实际上添加了一个名为 age 的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以 delete age 返回 true.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>59.输出是什么？ 2021-04-21</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
<span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">numbers</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">y</span>);
</code></pre></div><ul>
<li>A: [[1, 2, 3, 4, 5]]</li>
<li>B: [1, 2, 3, 4, 5]</li>
<li>C: 1</li>
<li>D: [1]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
可以通过结构赋值来解析来自对象的数组或属性的值：
[a, b] = [1, 2];</p>
<p>a 的值现在是 1， b 的值现在是 2.在题目中，我们是这么做的：
[y] = [1, 2, 3, 4, 5];</p>
<p>也就是说，y 等于数组的第一个值就是数字 1. 所以我们输出 y，返回 1.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>60.输出是什么？ 2021-04-21</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lydia&#39;</span>, <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">21</span> };
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">admin</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">admin</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>, ...<span style="color:#a6e22e">user</span> };

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">admin</span>);
</code></pre></div><ul>
<li>A: { admin: true, user: { name: &ldquo;Lydia&rdquo;, age: 21 } }</li>
<li>B: { admin: true, name: &ldquo;Lydia&rdquo;, age: 21 }</li>
<li>C: { admin: true, user: [&ldquo;Lydia&rdquo;, 21] }</li>
<li>D: { admin: true }</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
扩展运算符&hellip;为对象的组合提供了可能。你可以复制对象中的键值对，然后把它们加到另一个对象里去。在本例中，我们复制了 user 对象键值对，然后把它们加入到 admin 对象中。admin 对象就拥有了这些键值对，所以结果为{ admin: true, name: &ldquo;Lydia&rdquo;, age: 21 }</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>61.输出是什么？ 2021-04-22</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lydia&#34;</span>}
Object.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">person</span>, <span style="color:#e6db74">&#34;age&#34;</span>, {<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">21</span>});
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>)
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">person</span>);)
</code></pre></div><ul>
<li>A: { name: &ldquo;Lydia&rdquo;, age: 21 }, [&ldquo;name&rdquo;, &ldquo;age&rdquo;]</li>
<li>B: { name: &ldquo;Lydia&rdquo;, age: 21 }, [&ldquo;name&rdquo;]</li>
<li>C: { name: &ldquo;Lydia&rdquo;}, [&ldquo;name&rdquo;, &ldquo;age&rdquo;]</li>
<li>D: { name: &ldquo;Lydia&rdquo;}, [&ldquo;age&rdquo;]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
通过 defineProperty 方法，我们可以给对象添加一个新属性，或者修改已经存在的属性。而我们使用 defineProperty 方法给对象添加了一个属性之后，属性默认为 不可枚举(not enumerable). Object.keys 方法仅返回对象中 可枚举(enumerable) 的属性，因此只剩下了&quot;name&rdquo;.</p>
<p>用 defineProperty 方法添加的属性默认不可变。你可以通过 writable, configurable 和 enumerable 属性来改变这一行为。这样的话， 相比于自己添加的属性，defineProperty 方法添加的属性有了更多的控制权。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>62.输出是什么？ 2021-04-22</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">settings</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">username</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;lydiahallie&#39;</span>,
  <span style="color:#a6e22e">level</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">19</span>,
  <span style="color:#a6e22e">health</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">90</span>,
};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>(<span style="color:#a6e22e">settings</span>, [<span style="color:#e6db74">&#39;level&#39;</span>, <span style="color:#e6db74">&#39;health&#39;</span>]);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</code></pre></div><ul>
<li>A: &ldquo;{&ldquo;level&rdquo;:19, &ldquo;health&rdquo;:90}&rdquo;</li>
<li>B: &ldquo;{&ldquo;username&rdquo;: &ldquo;lydiahallie&rdquo;}&rdquo;</li>
<li>C: &ldquo;[&ldquo;level&rdquo;, &ldquo;health&rdquo;]&rdquo;</li>
<li>D: &ldquo;{&ldquo;username&rdquo;: &ldquo;lydiahallie&rdquo;, &ldquo;level&rdquo;:19, &ldquo;health&rdquo;:90}&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
JSON.stringify 的第二个参数是 替代者(replacer). 替代者(replacer)可以是个函数或数组，用以控制哪些值如何被转换为字符串。</p>
<p>如果替代者(replacer)是个 数组 ，那么就只有包含在数组中的属性将会被转化为字符串。在本例中，只有名为&quot;level&quot; 和 &ldquo;health&rdquo; 的属性被包括进来， &ldquo;username&quot;则被排除在外。 data 就等于 &ldquo;{&ldquo;level&rdquo;:19, &ldquo;health&rdquo;:90}&rdquo;.</p>
<p>而如果替代者(replacer)是个 函数，这个函数将被对象的每个属性都调用一遍。 函数返回的值会成为这个属性的值，最终体现在转化后的 JSON 字符串中（译者注：Chrome 下，经过实验，如果所有属性均返回同一个值的时候有异常，会直接将返回值作为结果输出而不会输出 JSON 字符串），而如果返回值为 undefined，则该属性会被排除在外。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>63.输出是什么？ 2021-04-22</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">increaseNumber</span> <span style="color:#f92672">=</span> () =&gt; <span style="color:#a6e22e">num</span><span style="color:#f92672">++</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">increasePassedNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">number</span>) =&gt; <span style="color:#a6e22e">number</span><span style="color:#f92672">++</span>;

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">num1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">increaseNumber</span>();
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">num2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">increasePassedNumber</span>(<span style="color:#a6e22e">num1</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">num1</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">num2</span>);
</code></pre></div><ul>
<li>A: 10, 10</li>
<li>B: 10, 11</li>
<li>C: 11, 11</li>
<li>D: 11, 12</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
一元操作符 ++ 先返回 操作值, 再累加 操作值。num1 的值是 10, 因为 increaseNumber 函数首先返回 num 的值，也就是 10，随后再进行 num 的累加。</p>
<p>num2 是 10 因为我们将 num1 传入 increasePassedNumber. number 等于 10（num1 的值。同样道理，++ 先返回 操作值, 再累加 操作值。） number 是 10，所以 num2 也是 10.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>64.输出是什么？ 2021-04-23</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">number</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span> };

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">multiply</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> { ...<span style="color:#a6e22e">value</span> }) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>((<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">number</span> <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>));
};
<span style="color:#a6e22e">multiply</span>();
<span style="color:#a6e22e">multiply</span>();
<span style="color:#a6e22e">multiply</span>(<span style="color:#a6e22e">value</span>);
<span style="color:#a6e22e">multiply</span>(<span style="color:#a6e22e">value</span>);
</code></pre></div><ul>
<li>A: 20, 40, 80, 160</li>
<li>B: 20, 40, 20, 40</li>
<li>C: 20, 20, 20, 40</li>
<li>D: NaN, NaN, 20, 40</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
在 ES6 中，我们可以使用默认值初始化参数。如果没有给函数传参，或者传的参值为 &ldquo;undefined&rdquo; ，那么参数的值将是默认值。上述例子中，我们将 value 对象进行了解构并传到一个新对象中，因此 x 的默认值为 {number：10} 。</p>
<p>默认参数在调用时才会进行计算，每次调用函数时，都会创建一个新的对象。我们前两次调用 multiply 函数且不传递值，那么每一次 x 的默认值都为 {number：10} ，因此打印出该数字的乘积值为 20。</p>
<p>第三次调用 multiply 时，我们传递了一个参数，即对象 value。 _=运算符实际上是 x.number = x.number _ 2 的简写，我们修改了 x.number 的值，并打印出值 20。</p>
<p>第四次，我们再次传递 value 对象。 x.number 之前被修改为 20，所以 x.number * = 2 打印为 40。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>65.输出是什么？ 2021-04-23</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>].<span style="color:#a6e22e">reduce</span>((<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>));
</code></pre></div><ul>
<li>A: 1 2 and 3 3 and 6 4</li>
<li>B: 1 2 and 2 3 and 3 4</li>
<li>C: 1 undefined and 2 undefined and 3 undefined and 4 undefined</li>
<li>D: 1 2 and undefined 3 and undefined 4</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
reducer 函数接收 4 个参数:</p>
<p>Accumulator (acc) (累计器)
Current Value (cur) (当前值)
Current Index (idx) (当前索引)
Source Array (src) (源数组)
reducer 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p>
<p>reducer 函数还有一个可选参数 initialValue, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供 initialValue，则将使用数组中的第一个元素。</p>
<p>在上述例子，reduce 方法接收的第一个参数(Accumulator)是 x, 第二个参数(Current Value)是 y。</p>
<p>在第一次调用时，累加器 x 为 1，当前值“y”为 2，打印出累加器和当前值：1 和 2。</p>
<p>例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回 undefined。 在下一次调用时，累加器为 undefined，当前值为“3”, 因此 undefined 和 3 被打印出。</p>
<p>在第四次调用时，回调函数依然没有返回值。 累加器再次为 undefined ，当前值为“4”。 undefined 和 4 被打印出。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>66.使用哪个构造函数可以成功继承 Dog 类？ 2021-04-23</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
  }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Labrador</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Dog</span> {
  <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">size</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">size</span>;
  }
  <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">size</span>) {
    <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">name</span>);
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">size</span>;
  }
  <span style="color:#75715e">// 3
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">size</span>) {
    <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">name</span>);
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">size</span>;
  }
  <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">size</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">size</span>;
  }
}
</code></pre></div><ul>
<li>A: 1</li>
<li>B: 2</li>
<li>C: 3</li>
<li>D: 4</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
在子类中，在调用 super 之前不能访问到 this 关键字。 如果这样做，它将抛出一个 ReferenceError：1 和 4 将引发一个引用错误。</p>
<p>使用 super 关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收 name 参数，因此我们需要将 name 传递给 super。</p>
<p>Labrador 类接收两个参数，name 参数是由于它继承了 Dog，size 作为 Labrador 类的额外属性，它们都需要传递给 Labrador 的构造函数，因此使用构造函数 2 正确完成。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>67.输出是什么？ 2021-04-24</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// index.js
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;running index.js&#39;</span>);
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">sum</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./sum.js&#39;</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sum</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>));

<span style="color:#75715e">// sum.js
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;running sum.js&#39;</span>);
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) =&gt; <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
</code></pre></div><ul>
<li>A: running index.js, running sum.js, 3</li>
<li>B: running sum.js, running index.js, 3</li>
<li>C: running sum.js, 3, running index.js</li>
<li>D: running index.js, undefined, running sum.js</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
import 命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。</p>
<p>这是 CommonJS 中 require（）和 import 之间的区别。使用 require()，您可以在运行代码时根据需要加载依赖项。 如果我们使用 require 而不是 import，running index.js，running sum.js，3 会被依次打印。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>68.输出是什么？ 2021-04-24</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Number(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">===</span> Number(<span style="color:#ae81ff">2</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Boolean(<span style="color:#66d9ef">false</span>) <span style="color:#f92672">===</span> Boolean(<span style="color:#66d9ef">false</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#39;foo&#39;</span>) <span style="color:#f92672">===</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#39;foo&#39;</span>));
</code></pre></div><ul>
<li>A: true, true, false</li>
<li>B: false, true, false</li>
<li>C: true, false, true</li>
<li>D: true, true, true</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
每个 Symbol 都是完全唯一的。传递给 Symbol 的参数只是给 Symbol 的一个描述。 Symbol 的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个 Symbol（&lsquo;foo&rsquo;），第二个 Symbol（&lsquo;foo&rsquo;）, 这两个值是唯一的，彼此不相等，因此返回 false。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>69.输出是什么？ 2021-04-24</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lydia Hallie&#39;</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">13</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">2</span>));
</code></pre></div><ul>
<li>A: &ldquo;Lydia Hallie&rdquo;, &ldquo;Lydia Hallie&rdquo;</li>
<li>B: &quot; Lydia Hallie&rdquo;, &quot; Lydia Hallie&quot; (&quot;[13x whitespace]Lydia Hallie&quot;, &ldquo;[2x whitespace]Lydia Hallie&rdquo;)</li>
<li>C: &quot; Lydia Hallie&quot;, &ldquo;Lydia Hallie&rdquo; (&quot;[1x whitespace]Lydia Hallie&quot;, &ldquo;Lydia Hallie&rdquo;)</li>
<li>D: &ldquo;Lydia Hallie&rdquo;, &ldquo;Lyd&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
使用 padStart 方法，我们可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串 Lydia Hallie 的长度为 12, 因此 name.padStart（13）在字符串的开头只会插入 1（13 - 12 = 1）个空格。</p>
<p>如果传递给 padStart 方法的参数小于字符串的长度，则不会添加填充。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>70.输出是什么？ 2021-04-24</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;🥑&#39;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;💻&#39;</span>);
</code></pre></div><ul>
<li>A: &ldquo;🥑💻&rdquo;</li>
<li>B: 257548</li>
<li>C: A string containing their code points</li>
<li>D: Error</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
使用+运算符，您可以连接字符串。 上述情况，我们将字符串“🥑”与字符串”💻“连接起来，产生”🥑💻“。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>71.如何能打印出 console.log 语句后注释掉的值？ 2021-04-25</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">startGame</span>() {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">答案</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;Do you love JavaScript?&#39;</span>;
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">答案</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;Yes&#39;</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Oh wow... Guess we&#39;re gone here&#34;</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;JavaScript loves you back ❤️&#39;</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">game</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">startGame</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#75715e">/* 1 */</span>); <span style="color:#75715e">// Do you love JavaScript?
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#75715e">/* 2 */</span>); <span style="color:#75715e">// JavaScript loves you back ❤️
</span></code></pre></div><ul>
<li>A: game.next(&ldquo;Yes&rdquo;).value and game.next().value</li>
<li>B: game.next.value(&ldquo;Yes&rdquo;) and game.next.value()</li>
<li>C: game.next().value and game.next(&ldquo;Yes&rdquo;).value</li>
<li>D: game.next.value() and game.next.value(&ldquo;Yes&rdquo;)</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
generator 函数在遇到 yield 关键字时会‘暂停’其执行。首先，我们要让函数产生字符串 Do you love javascript? 这可以通过调用 game.next().value 来完成。上述函数的第一行就有一个 yield 关键字，那么运行立即停止了。yield 表达式本身没有返回值，或者说总是返回 undefined，意味着变量 答案为 undefined。
next 方法可以带一个参数，该参数会被当做上一个 yield 表达式的返回值。当我们调用 game.next(&lsquo;YES&rsquo;).value 时，先前的 yield 的返回值将被替换为传递给 next()函数的参数‘Yes’。此时变量 答案 被赋值为 ‘Yes’，if 语句返回 false，所以所以 JavaScript loves you back ❤️ 被打印。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>72.输出是什么？ 2021-04-25</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(String.<span style="color:#a6e22e">raw</span><span style="color:#e6db74">`Hello\nworld`</span>);
</code></pre></div><ul>
<li>A: Hello world!</li>
<li>B: Hello
world!</li>
<li>C: Hello\nworld</li>
<li>D: Hello\n
world</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
String.raw 函数是用来获取一个模板字符串的原始字符串的，它返回一个字符串，其中忽略了转义符（\n，\v，\t 等）。但反斜杠可能造成问题，因为你可能会遇到下面这种类似情况：
const path = <code>C:\Documents\Projects\table.html</code>
String.raw<code>${path}</code>
这将导致：</p>
<p>&ldquo;C:DocumentsProjects able.html&rdquo;</p>
<p>直接使用 String.raw</p>
<p>String.raw<code>C:\Documents\Projects\table.html</code>
它会忽略转义字符并打印：C:\Documents\Projects\table.html</p>
<p>上述情况，字符串是 Hello\nworld 被打印出。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>73.输出是什么？ 2021-04-25</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getData</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;I made it!&#39;</span>);
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getData</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</code></pre></div><ul>
<li>A: &ldquo;I made it!&rdquo;</li>
<li>B: Promise {&lt; resolved &gt;: &ldquo;I made it!&quot;}</li>
<li>C: Promise {&lt; pending &gt;}</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
异步函数始终返回一个 promise。await 仍然需要等待 promise 的解决：当我们调用 getData()并将其赋值给 data，此时 data 为 getData 方法返回的一个挂起的 promise，该 promise 并没有解决。</p>
<p>如果我们想要访问已解决的值&quot;I made it!&quot;，可以在 data 上使用.then()方法：</p>
<p>data.then(res =&gt; console.log(res))</p>
<p>这样将打印 &ldquo;I made it!&rdquo;</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>74.输出是什么？ 2021-04-26</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">addToList</span>(<span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">list</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">list</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">item</span>);
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">addToList</span>(<span style="color:#e6db74">&#39;apple&#39;</span>, [<span style="color:#e6db74">&#39;banana&#39;</span>]);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>);
</code></pre></div><ul>
<li>A: [&lsquo;apple&rsquo;, &lsquo;banana&rsquo;]</li>
<li>B: 2</li>
<li>C: true</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
push()方法返回新数组的长度。一开始，数组包含一个元素（字符串&quot;banana&rdquo;），长度为 1。 在数组中添加字符串&quot;apple&quot;后，长度变为 2，并将从 addToList 函数返回。</p>
<p>push 方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在 push item 之后返回 list。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>75.输出是什么？ 2021-04-26</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">box</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">20</span> };
Object.<span style="color:#a6e22e">freeze</span>(<span style="color:#a6e22e">box</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shape</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">box</span>;
<span style="color:#a6e22e">shape</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">shape</span>);
</code></pre></div><ul>
<li>A: { x: 100, y: 20 }</li>
<li>B: { x: 10, y: 20 }</li>
<li>C: { x: 100 }</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
Object.freeze 使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。</p>
<p>当我们创建变量 shape 并将其设置为等于冻结对象 box 时，shape 指向的也是冻结对象。你可以使用 Object.isFrozen 检查一个对象是否被冻结，上述情况，Object.isFrozen（shape）将返回 true。</p>
<p>由于 shape 被冻结，并且 x 的值不是对象，所以我们不能修改属性 x。 x 仍然等于 10，{x：10，y：20}被打印。</p>
<p>注意，上述例子我们对属性 x 进行修改，可能会导致抛出 TypeError 异常（最常见但不仅限于严格模式下时）。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>76.输出是什么？ 2021-04-26</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">myName</span> } <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lydia&#39;</span> };
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>);
</code></pre></div><ul>
<li>A: &ldquo;Lydia&rdquo;</li>
<li>B: &ldquo;myName&rdquo;</li>
<li>C: undefined</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
当我们从右侧的对象解构属性 name 时，我们将其值 Lydia 分配给名为 myName 的变量。</p>
<p>使用{name：myName}，我们是在告诉 JavaScript 我们要创建一个名为 myName 的新变量，并且其值是右侧对象的 name 属性的值。</p>
<p>当我们尝试打印 name，一个未定义的变量时，就会引发 ReferenceError。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>77.以下是个纯函数么？ 2021-04-27</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> sun(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
}
</code></pre></div><ul>
<li>A: Yes</li>
<li>B: No</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
纯函数在相同的输入值时，需产生相同的输出，其输出的结果，与输入值以外的其他隐藏信息或状态无关，也和由 I/O 设备产生的外部输出无关。 纯函数不会产生副作用。</p>
<p>纯函数与副作用的定义可参考： <a href="https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)</a></p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>78.输出是什么？ 2021-04-27</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">add</span> <span style="color:#f92672">=</span> () =&gt; {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cache</span> <span style="color:#f92672">=</span> {};
  <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">num</span>) =&gt; {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">num</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">cache</span>) {
      <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`From cache! </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">num</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
      <span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">num</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">result</span>;
      <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`Calculated! </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">result</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
    }
  };
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">addFunction</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">add</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">addFunction</span>(<span style="color:#ae81ff">10</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">addFunction</span>(<span style="color:#ae81ff">10</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">addFunction</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>));
</code></pre></div><ul>
<li>A: Calculated! 20 Calculated! 20 Calculated! 20</li>
<li>B: Calculated! 20 From cache! 20 Calculated! 20</li>
<li>C: Calculated! 20 From cache! 20 From cache! 20</li>
<li>D: Calculated! 20 From cache! 20 Error</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
add 函数是一个记忆函数。 通过记忆化，我们可以缓存函数的结果，以加快其执行速度。上述情况，我们创建一个 cache 对象，用于存储先前返回过的值。</p>
<p>如果我们使用相同的参数多次调用 addFunction 函数，它首先检查缓存中是否已有该值，如果有，则返回缓存值，这将节省执行时间。如果没有，那么它将计算该值，并存储在缓存中。</p>
<p>我们用相同的值三次调用了 addFunction 函数：</p>
<p>在第一次调用，num 等于 10 时函数的值尚未缓存，if 语句 num in cache 返回 false，else 块的代码被执行：Calculated! 20，并且其结果被添加到缓存对象，cache 现在看起来像{10：20}。</p>
<p>第二次，cache 对象包含 10 的返回值。 if 语句 num in cache 返回 true，From cache! 20 被打印。</p>
<p>第三次，我们将 5 * 2(值为 10)传递给函数。 cache 对象包含 10 的返回值。 if 语句 num in cache 返回 true，From cache! 20 被打印。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>79.输出是什么？ 2021-04-27</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myLifeSummedUp</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;☕&#39;</span>, <span style="color:#e6db74">&#39;💻&#39;</span>, <span style="color:#e6db74">&#39;🍷&#39;</span>, <span style="color:#e6db74">&#39;🍫&#39;</span>];

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">myLifeSummedUp</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>);
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">myLifeSummedUp</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>);
}
</code></pre></div><ul>
<li>A: 0 1 2 3 and &ldquo;☕&rdquo; &ldquo;💻&rdquo; &ldquo;🍷&rdquo; &ldquo;🍫&rdquo;</li>
<li>B: &ldquo;☕&rdquo; &ldquo;💻&rdquo; &ldquo;🍷&rdquo; &ldquo;🍫&rdquo; and &ldquo;☕&rdquo; &ldquo;💻&rdquo; &ldquo;🍷&rdquo; &ldquo;🍫&rdquo;</li>
<li>C: &ldquo;☕&rdquo; &ldquo;💻&rdquo; &ldquo;🍷&rdquo; &ldquo;🍫&rdquo; and 0 1 2 3</li>
<li>D: 0 1 2 3 and {0: &ldquo;☕&rdquo;, 1: &ldquo;💻&rdquo;, 2: &ldquo;🍷&rdquo;, 3: &ldquo;🍫&rdquo;}</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
通过 for-in 循环，我们可以遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。 在数组中，可枚举属性是数组元素的“键”， 即它们的索引。 类似于下面这个对象：</p>
<p>{0: &ldquo;☕&rdquo;, 1: &ldquo;💻&rdquo;, 2: &ldquo;🍷&rdquo;, 3: &ldquo;🍫&rdquo;}</p>
<p>其中键则是可枚举属性，因此 0，1，2，3 被记录。</p>
<p>通过 for-of 循环，我们可以迭代可迭代对象（包括 Array，Map，Set，String，arguments 等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量 item, 因此“☕”，“💻”，“🍷”，“🍫”被打印。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>80.输出是什么？ 2021-04-28</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">list</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>];
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">list</span>);
</code></pre></div><ul>
<li>A: [&ldquo;1 + 2&rdquo;, &ldquo;1 * 2&rdquo;, &ldquo;1 / 2&rdquo;]</li>
<li>B: [&ldquo;12&rdquo;, 2, 0.5]</li>
<li>C: [3, 2, 0.5]</li>
<li>D: [1, 1, 1]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
数组元素可以包含任何值。 数字，字符串，布尔值，对象，数组，null，undeifned, 以及其他表达式，如日期，函数和计算。</p>
<p>元素将等于返回的值。 1 + 2 返回 3，1 * 2 返回'2，&lsquo;1 / 2 返回 0.5。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>81.输出是什么？ 2021-04-28</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHi</span>(<span style="color:#a6e22e">name</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`Hi there, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
}
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sayHi</span>());
</code></pre></div><ul>
<li>A: Hi there,</li>
<li>B: Hi there, undefined</li>
<li>C: Hi there, null</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
默认情况下，如果不给函数传参，参数的值将为 undefined。 上述情况，我们没有给参数 name 传值。 name 等于 undefined，并被打印。</p>
<p>在 ES6 中，我们可以使用默认参数覆盖此默认的 undefined 值。 例如：</p>
<p>function sayHi（name =“Lydia”）{&hellip;}</p>
<p>在这种情况下，如果我们没有传递值或者如果我们传递 undefined，name 总是等于字符串 Lydia</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>82.输出是什么？ 2021-04-28</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;😎&#39;</span>;

<span style="color:#a6e22e">setTimeout</span>(() =&gt; {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">status</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;😍&#39;</span>;

  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">status</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;🥑&#39;</span>,
    <span style="color:#a6e22e">getStatus</span>() {
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span>;
    },
  };

  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">getStatus</span>());
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">getStatus</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>));
}, <span style="color:#ae81ff">0</span>);
</code></pre></div><ul>
<li>A: &ldquo;🥑&rdquo; and &ldquo;😍&rdquo;</li>
<li>B: &ldquo;🥑&rdquo; and &ldquo;😎&rdquo;</li>
<li>C: &ldquo;😍&rdquo; and &ldquo;😎&rdquo;</li>
<li>D: &ldquo;😎&rdquo; and &ldquo;😎&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
this 关键字的指向取决于使用它的位置。 在函数中，比如 getStatus，this 指向的是调用它的对象，上述例子中 data 对象调用了 getStatus，因此 this 指向的就是 data 对象。 当我们打印 this.status 时，data 对象的 status 属性被打印，即&quot;🥑&quot;。</p>
<p>使用 call 方法，可以更改 this 指向的对象。data.getStatus.call(this)是将 this 的指向由 data 对象更改为全局对象。在全局对象上，有一个名为 status 的变量，其值为”😎“。 因此打印 this.status 时，会打印“😎”。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>83.输出是什么？ 2021-04-28</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span>,
  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">27</span>,
};

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">city</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">city</span>;
<span style="color:#a6e22e">city</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Fuzhou&#39;</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>);
</code></pre></div><ul>
<li>A: {name: &ldquo;WannTonn&rdquo;, age: 27}</li>
<li>B: {name: &ldquo;WannTonn&rdquo;, age: 27, city: &ldquo;Fuzhou&rdquo;}</li>
<li>C: {name: &ldquo;WannTonn&rdquo;, age: 27, city: undefined}</li>
<li>D: &ldquo;Fuzhou&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
我们将变量 city 设置为等于 person 对象上名为 city 的属性的值。 这个对象上没有名为 city 的属性，因此变量 city 的值为 undefined。</p>
<p>请注意，我们没有引用 person 对象本身，只是将变量 city 设置为等于 person 对象上 city 属性的当前值。</p>
<p>然后，我们将 city 设置为等于字符串“Fuzhou”。 这不会更改 person 对象：没有对该对象的引用。</p>
<p>因此打印 person 对象时，会返回未修改的对象。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>84.输出是什么？ 2021-04-28</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">fucntion</span> <span style="color:#a6e22e">checkAge</span>(<span style="color:#a6e22e">age</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">age</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">18</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Too young.&#34;</span>;
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Old enough!&#34;</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">message</span>;
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">checkAge</span>(<span style="color:#ae81ff">21</span>))
</code></pre></div><ul>
<li>A: &ldquo;Too young.&rdquo;</li>
<li>B: &ldquo;Old enough!&rdquo;</li>
<li>C: ReferenceError</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
const 和 let 声明的变量是具有块级作用域的，块是大括号（{}）之间的任何东西, 即上述情况 if / else 语句的花括号。 由于块级作用域，我们无法在声明的块之外引用变量，因此抛出 ReferenceError。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>85.什么样的信息将被打印？ 2021-04-28</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;https://www.google.com&#39;</span>)
  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">res</span>) =&gt; <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">json</span>())
  .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">res</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>));
</code></pre></div><ul>
<li>A: fetch 方法的结果</li>
<li>B: 第二次调用 fetch 方法的结果</li>
<li>C: 前一个.then()中回调方法返回的结果</li>
<li>D: 总是 undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
第二个.then 中 res 的值等于前一个.then 中的回调函数返回的值。 你可以像这样继续链接.then，将值传递给下一个处理程序。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<ol start="86">
<li>哪个选项是将 hasName 设置为 true 的方法，前提是不能将 true 作为参数传递? 2021-04-29</li>
</ol>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getName</span>(<span style="color:#a6e22e">name</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasName</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>A: !!name</li>
<li>B: name</li>
<li>C: new Boolean(name)</li>
<li>D: name.length</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
使用逻辑非运算符!，将返回一个布尔值，使用!! name，我们可以确定 name 的值是真的还是假的。 如果 name 是真实的，那么!name 返回 false。 !false 返回 true。</p>
<p>通过将 hasName 设置为 name，可以将 hasName 设置为等于传递给 getName 函数的值，而不是布尔值 true。</p>
<p>new Boolean（true）返回一个对象包装器，而不是布尔值本身。</p>
<p>name.length 返回传递的参数的长度，而不是布尔值 true。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>87.输出是什么？ 2021-04-29</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;I want pizza&#39;</span>[<span style="color:#ae81ff">0</span>]);
</code></pre></div><ul>
<li>A: &quot;&quot;&quot;</li>
<li>B:&ldquo;I&rdquo;</li>
<li>C: SyntaxError</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
可以使用方括号表示法获取字符串中特定索引的字符，字符串中的第一个字符具有索引 0，依此类推。 在这种情况下，我们想要得到索引为 0 的元素，字符&rsquo;I&rsquo;被记录。</p>
<p>请注意，IE7 及更低版本不支持此方法。 在这种情况下，应该使用.charAt（）</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>88.输出是什么？ 2021-04-29</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">funciton</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">num1</span>, <span style="color:#a6e22e">num2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">num1</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">num1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">num2</span>);
}
<span style="color:#a6e22e">sum</span>(<span style="color:#ae81ff">10</span>)
</code></pre></div><ul>
<li>A: NaN</li>
<li>B: 20</li>
<li>C: ReferenceError</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
您可以将默认参数的值设置为函数的另一个参数，只要另一个参数定义在其之前即可。 我们将值 10 传递给 sum 函数。 如果 sum 函数只接收 1 个参数，则意味着没有传递 num2 的值，这种情况下，num1 的值等于传递的值 10。 num2 的默认值是 num1 的值，即 10。 num1 + num2 返回 20。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>89.输出是什么？ 2021-04-30</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
  }
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">member</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>(<span style="color:#e6db74">&#39;John&#39;</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">member</span>);
</code></pre></div><ul>
<li>A: &ldquo;class&rdquo;</li>
<li>B: &ldquo;function&rdquo;</li>
<li>C: &ldquo;object&rdquo;</li>
<li>D: &ldquo;string&rdquo;</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
类是构造函数的语法糖，如果用构造函数的方式来重写 Person 类则将是：</p>
<p>function Person() {
this.name = name
}
通过 new 来调用构造函数，将会生成构造函数 Person 的实例，对实例执行 typeof 关键字将返回&quot;object&quot;，上述情况打印出&quot;object&quot;。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>90.输出是什么？ 2021-04-30</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// module.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> () =&gt; <span style="color:#e6db74">&#39;Hello world&#39;</span>;
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lydia&#39;</span>;

<span style="color:#75715e">// index.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">data</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./module&#39;</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</code></pre></div><ul>
<li>A: { default: function default(), name: &ldquo;Lydia&rdquo; }</li>
<li>B: { default: function default() }</li>
<li>C: { default: &ldquo;Hello world&rdquo;, name: &ldquo;Lydia&rdquo; }</li>
<li>D: Global object of module.js</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
使用 import * as name 语法，我们将 module.js 文件中所有 export 导入到 index.js 文件中，并且创建了一个名为 data 的新对象。 在 module.js 文件中，有两个导出：默认导出和命名导出。 默认导出是一个返回字符串“Hello World”的函数，命名导出是一个名为 name 的变量，其值为字符串“Lydia”。</p>
<p>data 对象具有默认导出的 default 属性，其他属性具有指定 exports 的名称及其对应的值。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>91.输出是什么？ 2021-04-30</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">newList</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>].<span style="color:#a6e22e">push</span>(<span style="color:#ae81ff">4</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">newList</span>.<span style="color:#a6e22e">push</span>(<span style="color:#ae81ff">5</span>));
</code></pre></div><ul>
<li>A: [1, 2, 3, 4, 5]</li>
<li>B: [1, 2, 3, 5]</li>
<li>C: [1, 2, 3, 4]</li>
<li>D: Error</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
.push 方法返回数组的长度，而不是数组本身！ 通过将 newList 设置为[1,2,3].push(4)，实际上 newList 等于数组的新长度：4。</p>
<p>然后，尝试在 newList 上使用.push 方法。 由于 newList 是数值 4，抛出 TypeError。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>92.输出是什么？ 2021-05-01</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">giveMePizza</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;Here you are&#39;</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">giveMeDrink</span> <span style="color:#f92672">=</span> () =&gt; <span style="color:#e6db74">&#39;Hure you go,enjoy&#39;</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">giveMePizza</span>.<span style="color:#a6e22e">prototype</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">giveMeDrink</span>.<span style="color:#a6e22e">prototype</span>);
</code></pre></div><ul>
<li>A: { constructor: &hellip;} { constructor: &hellip;}</li>
<li>B: {} { constructor: &hellip;}</li>
<li>C: { constructor: &hellip;} {}</li>
<li>D: {constructor: &hellip;} undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
常规函数，例如 giveMePizza 函数， 有一个 prototype 属性，它是一个带有 constructor 属性的对象（原型对象）。然而，箭头函数，例如 giveMeDrink 函数，没有 prototype 属性。尝试使用 giveMeDrink.prototype 属性时会返回 undefined。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>93.输出是什么？ 2021-05-01</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span>,
  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">27</span>,
};

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>] <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">entries</span>(<span style="color:#a6e22e">person</span>)) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>);
}
</code></pre></div><ul>
<li>A: name WannTonn and age 27</li>
<li>B: [&ldquo;name&rdquo;, &ldquo;WannTonn&rdquo;] and [&ldquo;age&rdquo;, 27]</li>
<li>C: [&ldquo;name&rdquo;, &ldquo;age&rdquo;] and undefined</li>
<li>D: Error</li>
</ul>
<!-- raw HTML omitted -->
<p>答案:
<!-- raw HTML omitted -->
Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，上述情况返回一个二维数组，数组每个元素是一个包含键和值的数组：</p>
<p>[[&lsquo;name&rsquo;，&lsquo;WannTonn&rsquo;]，[&lsquo;age&rsquo;，27]]</p>
<p>使用 for-of 循环，我们可以迭代数组中的每个元素，上述情况是子数组。 我们可以使用 const [x，y]在 for-of 循环中解构子数组。 x 等于子数组中的第一个元素，y 等于子数组中的第二个元素。</p>
<p>第一个子阵列是[“name”，“WannTonn”]，其中 x 等于 name，而 y 等于 Lydia。 第二个子阵列是[“age”，27]，其中 x 等于 age，而 y 等于 27。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>94.输出是什么？ 2021-05-01</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getItems</span>(<span style="color:#a6e22e">fruitList</span>, ...<span style="color:#a6e22e">args</span>, <span style="color:#a6e22e">favoriteFruit</span>) {
  <span style="color:#66d9ef">return</span> [...<span style="color:#a6e22e">fruitList</span>, ...<span style="color:#a6e22e">args</span>, <span style="color:#a6e22e">favoriteFruit</span>]
}

<span style="color:#a6e22e">getItems</span>([<span style="color:#e6db74">&#34;banana&#34;</span>, <span style="color:#e6db74">&#34;apple&#34;</span>], <span style="color:#e6db74">&#34;pear&#34;</span>, <span style="color:#e6db74">&#34;orange&#34;</span>)
</code></pre></div><ul>
<li>A: [&ldquo;banana&rdquo;, &ldquo;apple&rdquo;, &ldquo;pear&rdquo;, &ldquo;orange&rdquo;]</li>
<li>B: [[&ldquo;banana&rdquo;, &ldquo;apple&rdquo;], &ldquo;pear&rdquo;, &ldquo;orange&rdquo;]</li>
<li>C: [&ldquo;banana&rdquo;, &ldquo;apple&rdquo;, [&ldquo;pear&rdquo;], &ldquo;orange&rdquo;]</li>
<li>D: SyntaxError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
&hellip; args 是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，并且只能作为最后一个参数。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getItems</span>(<span style="color:#a6e22e">fruitList</span>, <span style="color:#a6e22e">favoriteFruit</span>, ...<span style="color:#a6e22e">args</span>) {
  <span style="color:#66d9ef">return</span> [...<span style="color:#a6e22e">fruitList</span>, ...<span style="color:#a6e22e">args</span>, <span style="color:#a6e22e">favoriteFruit</span>];
}
</code></pre></div><p>getItems([&ldquo;banana&rdquo;, &ldquo;apple&rdquo;], &ldquo;pear&rdquo;, &ldquo;orange&rdquo;)
上述例子是有效的，将会返回数组：[ &lsquo;banana&rsquo;, &lsquo;apple&rsquo;, &lsquo;orange&rsquo;, &lsquo;pear&rsquo; ]</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>95.输出是什么？ 2021-05-02</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">fucntion</span> <span style="color:#a6e22e">nums</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
  <span style="color:#66d9ef">if</span>
  (<span style="color:#a6e22e">a</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">b</span>)
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;a is bigger&#39;</span>);
  <span style="color:#66d9ef">else</span>
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;b is bigger&#39;</span>);
  <span style="color:#66d9ef">return</span>
  <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">nums</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">nums</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>));
</code></pre></div><ul>
<li>A: a is bigger, 6 and b is bigger, 3</li>
<li>B: a is bigger, undefined and b is bigger, undefined</li>
<li>C: undefined and undefined</li>
<li>D: SyntaxError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
在 JavaScript 中，我们不必显式地编写分号(;)，但是 JavaScript 引擎仍然在语句之后自动添加分号。这称为自动分号插入。例如，一个语句可以是变量，或者像 throw、return、break 这样的关键字。</p>
<p>在这里，我们在新的一行上写了一个 return 语句和另一个值 a + b 。然而，由于它是一个新行，引擎并不知道它实际上是我们想要返回的值。相反，它会在 return 后面自动添加分号。你可以这样看:</p>
<p>return;
a + b
这意味着永远不会到达 a + b，因为函数在 return 关键字之后停止运行。如果没有返回值，就像这里，函数返回 undefined。注意，在 if/else 语句之后没有自动插入!</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>96.输出是什么？ 2021-05-02</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">constructor</span>() {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span>;
  }
}

<span style="color:#a6e22e">Person</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AnothoerPerson</span> {
  <span style="color:#a6e22e">constructor</span>() {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Tyrant&#39;</span>;
  }
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">member</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">member</span>.<span style="color:#a6e22e">name</span>);
</code></pre></div><ul>
<li>A: &ldquo;WannTonn&rdquo;</li>
<li>B: &ldquo;Tyrant&rdquo;</li>
<li>C: Error: cannot redeclare Person</li>
<li>D: SyntaxError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
我们可以将类设置为等于其他类/函数构造函数。 在这种情况下，我们将 Person 设置为 AnotherPerson。 这个构造函数的名字是 Sarah，所以新的 Person 实例 member 上的 name 属性是 Sarah。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>97.输出是什么？ 2021-05-02</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">info</span> <span style="color:#f92672">=</span> {
  [<span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#39;a&#39;</span>)]<span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;b&#39;</span>,
};

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">info</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">info</span>));
</code></pre></div><ul>
<li>A: {Symbol(&lsquo;a&rsquo;): &lsquo;b&rsquo;} and [&quot;{Symbol(&lsquo;a&rsquo;)&quot;]</li>
<li>B: {} and []</li>
<li>C: { a: &ldquo;b&rdquo; } and [&ldquo;a&rdquo;]</li>
<li>D: {Symbol(&lsquo;a&rsquo;): &lsquo;b&rsquo;} and []</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
Symbol 类型是不可枚举的。Object.keys 方法返回对象上的所有可枚举的键属性。Symbol 类型是不可见的，并返回一个空数组。 记录整个对象时，所有属性都是可见的，甚至是不可枚举的属性。</p>
<p>这是 Symbol 的众多特性之一：除了表示完全唯一的值（防止对象意外名称冲突，例如当使用 2 个想要向同一对象添加属性的库时），您还可以隐藏这种方式对象的属性（尽管不完全。你仍然可以使用 Object.getOwnPropertySymbols()方法访问 Symbol。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>98.输出是什么？ 2021-05-03</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getList</span> <span style="color:#f92672">=</span> ([<span style="color:#a6e22e">x</span>, ...<span style="color:#a6e22e">y</span>]) =&gt; [<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>];
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getUser</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">user</span> =&gt; {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">age</span>};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">list</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;WannTonn&#34;</span>, <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">27</span>};

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getList</span>(<span style="color:#a6e22e">list</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getUser</span>(<span style="color:#a6e22e">user</span>));
</code></pre></div><ul>
<li>A: [1, [2, 3, 4]] and undefined</li>
<li>B: [1, [2, 3, 4]] and { name: &ldquo;WannTonn&rdquo;, age: 27 }</li>
<li>C: [1, 2, 3, 4] and { name: &ldquo;WannTonn&rdquo;, age: 27 }</li>
<li>D: Error and { name: &ldquo;WannTonn&rdquo;, age: 27 }</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
getList 函数接收一个数组作为其参数。 在 getList 函数的括号之间，我们立即解构这个数组。 您可以将其视为：</p>
<p>[x, &hellip;y] = [1, 2, 3, 4]</p>
<p>使用剩余的参数&hellip; y，我们将所有剩余参数放在一个数组中。 在这种情况下，其余的参数是 2，3 和 4。 y 的值是一个数组，包含所有其余参数。 在这种情况下，x 的值等于 1，所以当我们打印[x，y]时，会打印[1，[2,3,4]]。</p>
<p>getUser 函数接收一个对象。对于箭头函数，如果只返回一个值，我们不必编写花括号。但是，如果您想从一个箭头函数返回一个对象，您必须在圆括号之间编写它，否则不会返回任何值!下面的函数将返回一个对象:</p>
<p>const getUser = user =&gt; ({ name: user.name, age: user.age })</p>
<p>由于在这种情况下不返回任何值，因此该函数返回 undefined。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>99.输出是什么？ 2021-05-03</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>());
</code></pre></div><ul>
<li>A: SyntaxError</li>
<li>B: ReferenceError</li>
<li>C: TypeError</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
变量 name 保存字符串的值，该字符串不是函数，因此无法调用。</p>
<p>当值不是预期类型时，会抛出 TypeErrors。 JavaScript 期望 name 是一个函数，因为我们试图调用它。 但它是一个字符串，因此抛出 TypeError：name is not a function</p>
<p>当你编写了一些非有效的 JavaScript 时，会抛出语法错误，例如当你把 return 这个词写成 retrun 时。 当 JavaScript 无法找到您尝试访问的值的引用时，抛出 ReferenceErrors。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>100.输出是什么？ 2021-05-03</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 🎉✨ This is my 100th question! ✨🎉
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">output</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span>[] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#39;Im&#39;</span><span style="color:#e6db74">}</span><span style="color:#e6db74">possible!
</span><span style="color:#e6db74">You should</span><span style="color:#e6db74">${</span><span style="color:#e6db74">&#39;&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">`n&#39;t`</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> see a therapist after so much JavaScript lol`</span>;
</code></pre></div><ul>
<li>A: possible! You should see a therapist after so much JavaScript lol</li>
<li>B: Impossible! You should see a therapist after so much JavaScript lol</li>
<li>C: possible! You shouldn&rsquo;t see a therapist after so much JavaScript lol</li>
<li>D: Impossible! You shouldn&rsquo;t see a therapist after so much JavaScript lol</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
[]是一个真值。 使用&amp;&amp;运算符，如果左侧值是真值，则返回右侧值。 在这种情况下，左侧值[]是一个真值，所以返回 Im。</p>
<p>&ldquo;&ldquo;是一个假值。 如果左侧值是假的，则不返回任何内容。 n&rsquo;t 不会被返回。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>101.输出是什么？ 2021-05-04</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span> <span style="color:#f92672">||</span> {} <span style="color:#f92672">||</span> <span style="color:#66d9ef">null</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">false</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#39;&#39;</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">three</span> <span style="color:#f92672">=</span> [] <span style="color:#f92672">||</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">true</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">one</span>, <span style="color:#a6e22e">two</span>, <span style="color:#a6e22e">three</span>);
</code></pre></div><ul>
<li>A: false null []</li>
<li>B: null &quot;&rdquo; true</li>
<li>C: {} &quot;&rdquo; []</li>
<li>D: null null true</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
使用||运算符，我们可以返回第一个真值。 如果所有值都是假值，则返回最后一个值。</p>
<p>（false || {} || null）：空对象{}是一个真值。 这是第一个（也是唯一的）真值，它将被返回。one 等于{}。</p>
<p>（null || false ||“”）：所有值都是假值。 这意味着返回传递的值&quot;&quot;。 two 等于&quot;&quot;。</p>
<p>（[] || 0 ||“”）：空数组[]是一个真值。 这是第一个返回的真值。 three 等于[]。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>102.输出是什么？ 2021-05-04</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myPromise</span> <span style="color:#f92672">=</span> () =&gt; Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;I have resolved!&#39;</span>);

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstFunciton</span>() {
  <span style="color:#a6e22e">myPromise</span>().<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">res</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>));
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;second&#39;</span>);
}

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">secondFunction</span>() {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">myPromise</span>());
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;second&#39;</span>);
}
<span style="color:#a6e22e">fisrtFunction</span>();
<span style="color:#a6e22e">secondFunction</span>();
</code></pre></div><ul>
<li>A: I have resolved!, second and I have resolved!, second</li>
<li>B: second, I have resolved! and second, I have resolved!</li>
<li>C: I have resolved!, second and second, I have resolved!</li>
<li>D: second, I have resolved! and I have resolved!, second</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
有了 promise，我们通常会说：当我想要调用某个方法，但是由于它可能需要一段时间，因此暂时将它放在一边。只有当某个值被 resolved/rejected，并且执行栈为空时才使用这个值。</p>
<p>我们可以在 async 函数中通过.then 和 await 关键字获得该值。 尽管我们可以通过.then 和 await 获得 promise 的价值，但是它们的工作方式有所不同。</p>
<p>在 firstFunction 中，当运行到 myPromise 方法时我们将其放在一边，即 promise 进入微任务队列，其他后面的代码（console.log(&lsquo;second&rsquo;)）照常运行，因此 second 被打印出，firstFunction 方法到此执行完毕，执行栈中宏任务队列被清空，此时开始执行微任务队列中的任务，I have resolved 被打印出。</p>
<p>在 secondFunction 方法中，我们通过 await 关键字，暂停了后面代码的执行，直到异步函数的值被解析才开始后面代码的执行。这意味着，它会等着直到 myPromise 以值 I have resolved 被解决之后，下一行 second 才开始执行。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>103.输出是什么？ 2021-05-04</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">set</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>();

<span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#39;Lydia&#39;</span>);
<span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">add</span>({ <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lydia&#39;</span> });

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">set</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
}
</code></pre></div><ul>
<li>A: 3, NaN, NaN</li>
<li>B: 3, 7, NaN</li>
<li>C: 3, Lydia2, [Object object]2</li>
<li>D: &ldquo;12&rdquo;, Lydia2, [Object object]2</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
“+”运算符不仅用于添加数值，还可以使用它来连接字符串。 每当 JavaScript 引擎发现一个或多个值不是数字时，就会将数字强制为字符串。</p>
<p>第一个是数字 1。 1 + 2 返回数字 3。</p>
<p>但是，第二个是字符串“Lydia”。 “Lydia”是一个字符串，2 是一个数字：2 被强制转换为字符串。 “Lydia”和“2”被连接起来，产生字符串“Lydia2”。</p>
<p>{name：“ Lydia”}是一个对象。 数字和对象都不是字符串，因此将二者都字符串化。 每当我们对常规对象进行字符串化时，它就会变成[Object object]。 与“2”串联的“ [Object object]”成为“[Object object]2”。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>104.输出是什么？ 2021-05-05</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">5</span>);
</code></pre></div><ul>
<li>A: 5</li>
<li>B: Promise {&lt; pending &gt;: 5}</li>
<li>C: Promise {&lt; fulfilled &gt;: 5}</li>
<li>D: Error</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
我们可以将我们想要的任何类型的值传递 Promise.resolve，无论是否 promise。 该方法本身返回带有已解析值的 Promise (&lt; fulfilled &gt;)。 如果您传递常规函数，它将是具有常规值的已解决 promise。 如果你通过了 promise，它将是一个已经 resolved 的且带有传的值的 promise。</p>
<p>上述情况，我们传了数字 5，因此返回一个 resolved 状态的 promise，resolve 值为 5</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>105.输出是什么？ 2021-05-05</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">compareMembers</span>(<span style="color:#a6e22e">person1</span>, <span style="color:#a6e22e">person2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">person</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">person1</span> <span style="color:#f92672">!==</span> <span style="color:#a6e22e">person2</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Not the same!&#39;</span>);
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;They are the same!&#39;</span>);
  }
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span> };
<span style="color:#a6e22e">compareMembers</span>(<span style="color:#a6e22e">person</span>);
</code></pre></div><ul>
<li>A: Not the same!</li>
<li>B: They are the same!</li>
<li>C: ReferenceError</li>
<li>D: SyntaxError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
对象通过引用传递。 当我们检查对象的严格相等性（===）时，我们正在比较它们的引用。</p>
<p>我们将“person2”的默认值设置为“person”对象，并将“person”对象作为“person1”的值传递。</p>
<p>这意味着两个值都引用内存中的同一位置，因此它们是相等的。</p>
<p>运行“ else”语句中的代码块，并记录 They are the same! 。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>106.输出是什么？ 2021-05-05</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">colorConfig</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">red</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
  <span style="color:#a6e22e">blue</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
  <span style="color:#a6e22e">green</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
  <span style="color:#a6e22e">black</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
  <span style="color:#a6e22e">yellow</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">colors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;pink&#39;</span>, <span style="color:#e6db74">&#39;red&#39;</span>, <span style="color:#e6db74">&#39;blue&#39;</span>];

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">colorConfig</span>.<span style="color:#a6e22e">colors</span>[<span style="color:#ae81ff">1</span>]);
</code></pre></div><ul>
<li>A: true</li>
<li>B: false</li>
<li>C: undefined</li>
<li>D: TypeError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
在 JavaScript 中，我们有两种访问对象属性的方法：括号表示法或点表示法。 在此示例中，我们使用点表示法（colorConfig.colors）代替括号表示法（colorConfig [“ colors”]）。</p>
<p>使用点表示法，JavaScript 会尝试使用该确切名称在对象上查找属性。 在此示例中，JavaScript 尝试在 colorconfig 对象上找到名为 colors 的属性。 没有名为“colors”的属性，因此返回“undefined”。 然后，我们尝试使用[1]访问第一个元素的值。 我们无法对未定义的值执行此操作，因此会抛出 Cannot read property &lsquo;1&rsquo; of undefined。</p>
<p>JavaScript 解释（或取消装箱）语句。 当我们使用方括号表示法时，它会看到第一个左方括号[并一直进行下去，直到找到右方括号]。 只有这样，它才会评估该语句。 如果我们使用了 colorConfig [colors [1]]，它将返回 colorConfig 对象上 red 属性的值。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>107.输出是什么？ 2021-05-06</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;❤️&#39;</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;❤️&#39;</span>);
</code></pre></div><ul>
<li>A: true</li>
<li>B: false</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
在 JavaScript 内部，表情符号是 Unicode。爱心的表情符号对应的 Unicode 码是 &ldquo;U + 2764 U + FE0F&rdquo;, 对于相同的表情符号，它们总是相同的，因此我们将 2 个相等的字符串相互比较，将返回 true。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>108.哪些方法修改了原数组？ 2021-05-06</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">emojis</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;✨&#39;</span>, <span style="color:#e6db74">&#39;🥑&#39;</span>, <span style="color:#e6db74">&#39;😍&#39;</span>];

<span style="color:#a6e22e">emojis</span>.<span style="color:#a6e22e">map</span>((<span style="color:#a6e22e">x</span>) =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;✨&#39;</span>);
<span style="color:#a6e22e">emojis</span>.<span style="color:#a6e22e">filter</span>((<span style="color:#a6e22e">x</span>) =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;🥑&#39;</span>);
<span style="color:#a6e22e">emojis</span>.<span style="color:#a6e22e">find</span>((<span style="color:#a6e22e">x</span>) =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;🥑&#39;</span>);
<span style="color:#a6e22e">emojis</span>.<span style="color:#a6e22e">reduce</span>((<span style="color:#a6e22e">acc</span>, <span style="color:#a6e22e">cur</span>) =&gt; <span style="color:#a6e22e">acc</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;✨&#39;</span>);
<span style="color:#a6e22e">emojis</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;✨&#39;</span>);
<span style="color:#a6e22e">emojis</span>.<span style="color:#a6e22e">splice</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;✨&#39;</span>);
</code></pre></div><ul>
<li>A: All of them</li>
<li>B: map reduce slice splice</li>
<li>C: map slice splice</li>
<li>D: splice</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
使用 splice 方法，我们通过删除，替换或添加元素来修改原始数组。 在这种情况下，我们从索引 1 中删除了 2 个元素（我们删除了'🥑'和'😍&rsquo;），同时添加了 ✨emoji 表情。</p>
<p>map，filter 和 slice 返回一个新数组，find 返回一个元素，而 reduce 返回一个减小的值。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>109.输出是什么？ 2021-05-06</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">food</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;🍕&#39;</span>, <span style="color:#e6db74">&#39;🍫&#39;</span>, <span style="color:#e6db74">&#39;🥑&#39;</span>, <span style="color:#e6db74">&#39;🍔&#39;</span>];
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">info</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">favoriteFood</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">food</span>[<span style="color:#ae81ff">0</span>] };

<span style="color:#a6e22e">info</span>.<span style="color:#a6e22e">favoriteFood</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;🍝&#39;</span>;

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">food</span>);
</code></pre></div><ul>
<li>A: [&lsquo;🍕&rsquo;, &lsquo;🍫&rsquo;, &lsquo;🥑&rsquo;, &lsquo;🍔&rsquo;]</li>
<li>B: [&lsquo;🍝&rsquo;, &lsquo;🍫&rsquo;, &lsquo;🥑&rsquo;, &lsquo;🍔&rsquo;]</li>
<li>C: [&lsquo;🍝&rsquo;, &lsquo;🍕&rsquo;, &lsquo;🍫&rsquo;, &lsquo;🥑&rsquo;, &lsquo;🍔&rsquo;]</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
我们将 info 对象上的 favoriteFood 属性的值设置为披萨表情符号“🍕”的字符串。字符串是原始数据类型。在 JavaScript 中，原始数据类型通过值起作用</p>
<p>在这种情况下，我们将 info 对象上的 favoriteFood 属性的值设置为等于 food 数组中的第一个元素的值，字符串为披萨表情符号（&lsquo;🍕&rsquo; ）。字符串是原始数据类型，并且通过值进行交互，我们更改 info 对象上 favoriteFood 属性的值。 food 数组没有改变，因为 favoriteFood 的值只是该数组中第一个元素的值的复制，并且与该元素上的元素没有相同的内存引用食物[0]。当我们记录食物时，它仍然是原始数组[&lsquo;🍕&rsquo;，&lsquo;🍫&rsquo;，&lsquo;🥑&rsquo;，&lsquo;🍔&rsquo;]。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>110.这个函数干了什么？ 2021-05-07</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>();
</code></pre></div><ul>
<li>A: Parses JSON to a JavaScript value</li>
<li>B: Parses a JavaScript object to JSON</li>
<li>C: Parses any JavaScript value to JSON</li>
<li>D: Parses JSON to a JavaScript object only</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
使用 JSON.parse(), 我们可以将 JSON 字符串解析为 JavaScript 值。
// 将数字字符串化为有效的 JSON，然后将 JSON 字符串解析为 JavaScript 值:
const jsonNumber = JSON.stringify(4) // &lsquo;4&rsquo;
JSON.parse(jsonNumber) // 4</p>
<p>// 将数组值字符串化为有效的 JSON，然后将 JSON 字符串解析为 JavaScript 值:
const jsonArray = JSON.stringify([1, 2, 3]) // &lsquo;[1, 2, 3]&rsquo;
JSON.parse(jsonArray) // [1, 2, 3]</p>
<p>// 将对象字符串化为有效的 JSON，然后将 JSON 字符串解析为 JavaScript 值:
const jsonArray = JSON.stringify({ name: &ldquo;Lydia&rdquo; }) // &lsquo;{&ldquo;name&rdquo;:&ldquo;Lydia&rdquo;}&rsquo;
JSON.parse(jsonArray) // { name: &lsquo;Lydia&rsquo; }</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>111.输出是什么？ 2021-05-07</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span>;
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getName</span>() {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>);
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Joe&#39;</span>;
}

<span style="color:#a6e22e">getName</span>();
</code></pre></div><ul>
<li>A: WannTonn</li>
<li>B: Joe</li>
<li>C: undefined</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
每个函数都有其自己的执行上下文。 getName 函数首先在其自身的上下文（范围）内查找，以查看其是否包含我们尝试访问的变量 name。 上述情况，getName 函数包含其自己的 name 变量：我们用 let 关键字和 Sarah 的值声明变量 name。</p>
<p>带有 let 关键字（和 const）的变量被提升，但是与 var 不同，它不会被初始化。 在我们声明（初始化）它们之前，无法访问它们。 这称为“暂时性死区”。 当我们尝试在声明变量之前访问变量时，JavaScript 会抛出 ReferenceError: Cannot access &lsquo;name&rsquo; before initialization。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>112.输出是什么？ 2021-05-07</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">generatorOne</span>() {
  <span style="color:#66d9ef">yield</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>];
}
<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">generatorTwo</span>() {
  <span style="color:#66d9ef">yield</span><span style="color:#f92672">*</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>];
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generatorOne</span>();
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generatorTwo</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">one</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">two</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span>);
</code></pre></div><ul>
<li>A: a and a</li>
<li>B: a and undefined</li>
<li>C: [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;] and a</li>
<li>D: a and [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
通过 yield 关键字, 我们在 Generator 函数里执行 yield 表达式. 通过 yield* 关键字, 我们可以在一个 Generator 函数里面执行（yield 表达式）另一个 Generator 函数, 或可遍历的对象 (如数组).</p>
<p>在函数 generatorOne 中, 我们通过 yield 关键字 yield 了一个完整的数组 [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]。函数 one 通过 next 方法返回的对象的 value 属性的值 (one.next().value) 等价于数组 [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;].</p>
<p>console.log(one.next().value) // [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]
console.log(one.next().value) // undefined
在函数 generatorTwo 中, 我们使用 yield* 关键字。就相当于函数 two 第一个 yield 的值, 等价于在迭代器中第一个 yield 的值。数组[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]就是这个迭代器. 第一个 yield 的值就是 a, 所以我们第一次调用 two.next().value 时, 就返回 a。</p>
<p>console.log(two.next().value) // &lsquo;a&rsquo;
console.log(two.next().value) // &lsquo;b&rsquo;
console.log(two.next().value) // &lsquo;c&rsquo;
console.log(two.next().value) // undefined</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>113.输出是什么？ 2021-05-08</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span>((<span style="color:#a6e22e">x</span>) =&gt; <span style="color:#a6e22e">x</span>)(<span style="color:#e6db74">&#39;I love&#39;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74"> to program`</span>);
</code></pre></div><ul>
<li>A: I love to program</li>
<li>B: undefined to program</li>
<li>C: ${(x =&gt; x)(&lsquo;I love&rsquo;) to program</li>
<li>D: TypeError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
带有模板字面量的表达式首先被执行。相当于字符串会包含表达式，这个立即执行函数 (x =&gt; x)(&lsquo;I love&rsquo;) 返回的值. 我们向箭头函数 x =&gt; x 传递 &lsquo;I love&rsquo; 作为参数。x 等价于返回的 &lsquo;I love&rsquo;。这就是结果 I love to program。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>114.将会发生什么？ 2021-05-08</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">config</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">alert</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">setInterval</span>(() =&gt; {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Alert!&#39;</span>);
  }, <span style="color:#ae81ff">1000</span>),
};

<span style="color:#a6e22e">config</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</code></pre></div><ul>
<li>A: setInterval 的回调不会被调用</li>
<li>B: setInterval 的回调被调用一次</li>
<li>C: setInterval 的回调仍然会被每秒钟调用</li>
<li>D: 我们从没调用过 config.alert(), config 为 null</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
一般情况下当我们将对象赋值为 null, 那些对象会被进行 垃圾回收（garbage collected） 因为已经没有对这些对象的引用了。然而，setInterval 的参数是一个箭头函数（所以上下文绑定到对象 config 了），回调函数仍然保留着对 config 的引用。只要存在引用，对象就不会被垃圾回收。因为没有被垃圾回收，setInterval 的回调每 1000ms (1s)会被调用一次。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>115.输出是什么？ 2021-05-08</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">compareMembers</span>(<span style="color:#a6e22e">person1</span>, <span style="color:#a6e22e">person2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">person</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">person1</span> <span style="color:#f92672">!==</span> <span style="color:#a6e22e">person2</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Not the same!&#39;</span>);
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;They are the same!&#39;</span>);
  }
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span> };
<span style="color:#a6e22e">compareMembers</span>(<span style="color:#a6e22e">person</span>);
</code></pre></div><ul>
<li>A: Not the same!</li>
<li>B: They are the same!</li>
<li>C: ReferenceError</li>
<li>D: SyntaxError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
对象通过引用传递。 当我们检查对象的严格相等性（===）时，我们正在比较它们的引用。</p>
<p>我们将“person2”的默认值设置为“person”对象，并将“person”对象作为“person1”的值传递。</p>
<p>这意味着两个值都引用内存中的同一位置，因此它们是相等的。</p>
<p>运行“ else”语句中的代码块，并记录 They are the same! 。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>116.输出是什么？ 2021-05-09</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;WannTonn&#39;</span>,
  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">27</span>,
};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">changeAge</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> { ...<span style="color:#a6e22e">person</span> }) =&gt; (<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">changeAgeAndName</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> { ...<span style="color:#a6e22e">person</span> }) =&gt; {
  <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Evan&#39;</span>;
};
<span style="color:#a6e22e">changeAge</span>(<span style="color:#a6e22e">person</span>);
<span style="color:#a6e22e">changeAgeAndName</span>();

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>);
</code></pre></div><ul>
<li>A: {name: &ldquo;Evan&rdquo;, age: 28}</li>
<li>B: {name: &ldquo;Evan&rdquo;, age: 29}</li>
<li>C: {name: &ldquo;WannTonn&rdquo;, age: 28}</li>
<li>D: {name: &ldquo;WannTonn&rdquo;, age: 29}</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
函数 changeAge 和函数 changeAgeAndName 有着不同的参数，定义一个 新 生成的对象 { &hellip;person }。这个对象有着所有 person 对象 中 k/v 值的副本。</p>
<p>首项, 我们调用 changeAge 函数并传递 person 对象作为它的参数。这个函数对 age 属性进行加一操作。person 现在是 { name: &ldquo;WannTonn&rdquo;, age: 28 }。</p>
<p>然后，我们调用函数 changeAgeAndName ，然而我们没有传递参数。取而代之，x 的值等价 new 生成的对象: { &hellip;person }。因为它是一个新生成的对象，它并不会对对象 person 造成任何副作用。person 仍然等价于 { name: &ldquo;WannTonn&rdquo;, age: 28 }。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>117.下面那个选项将会返回 6？ 2021-05-09</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sumValues</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">z</span>;
}
</code></pre></div><ul>
<li>A: sumValues([&hellip;1, 2, 3])</li>
<li>B: sumValues([&hellip;[1, 2, 3]])</li>
<li>C: sumValues(&hellip;[1, 2, 3])</li>
<li>D: sumValues([1, 2, 3])</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
通过展开操作符 &hellip;，我们可以 暂开 单个可迭代的元素。函数 sumValues function 接收三个参数： x, y 和 z。&hellip;[1, 2, 3] 的执行结果为 1, 2, 3，将会传递给函数 sumValues。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>118.输出是什么？ 2021-05-09</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">list</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;🥳&#39;</span>, <span style="color:#e6db74">&#39;🤠&#39;</span>, <span style="color:#e6db74">&#39;🥰&#39;</span>, <span style="color:#e6db74">&#39;🤪&#39;</span>];

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">list</span>[(<span style="color:#a6e22e">num</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>)]);
</code></pre></div><ul>
<li>A: 🤠</li>
<li>B: 🥰</li>
<li>C: SyntaxError</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
通过 += 操作符，我们对值 num 进行加 1 操作。 num 有初始值 1，因此 1 + 1 的执行结果为 2。数组 list 的第二项为 🥰，console.log(list[2]) 输出 🥰.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>119.输出是什么？ 2021-05-10</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Wann&#39;</span>,
  <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Tonn&#39;</span>,
  <span style="color:#a6e22e">pet</span><span style="color:#f92672">:</span> {
    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Hachi&#39;</span>,
    <span style="color:#a6e22e">breed</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;土狗&#39;</span>,
  },
  <span style="color:#a6e22e">getFullName</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstName</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastName</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
  },
};

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">pet</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">name</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">pet</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">family</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">name</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">getFullName</span><span style="color:#f92672">?</span>.());
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">member</span>.<span style="color:#a6e22e">getLastName</span><span style="color:#f92672">?</span>.());
</code></pre></div><ul>
<li>A: undefined undefined undefined undefined</li>
<li>B: Hachi undefined Wann Tonn undefined</li>
<li>C: Hachi null Wann Tonn null</li>
<li>D: null ReferenceError null ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
通过 ES10 或 TS3.7+可选链操作符 ?.，我们不再需要显式检测更深层的嵌套值是否有效。如果我们尝试获取 undefined 或 null 的值 (nullish)，表达将会短路并返回 undefined.</p>
<p>person.pet?.name： person 有一个名为 pet 的属性： person.pet 不是 nullish。它有个名为 name 的属性，并返回字符串 Hachi。 person.pet?.family?.name： person 有一个名为 pet 的属性： person.pet 不是 nullish. pet 并没有 一个名为 family 的属性, person.pet.family 是 nullish。表达式返回 undefined。 person.getFullName?.()： person 有一个名为 getFullName 的属性： person.getFullName() 不是 nullish 并可以被调用，返回字符串 Wann Tonn。 member.getLastName?.(): member is not defined: member.getLastName() is nullish. The expression returns undefined.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>120.输出是什么？ 2021-05-10</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">groceries</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;banana&#39;</span>, <span style="color:#e6db74">&#39;apple&#39;</span>, <span style="color:#e6db74">&#39;peanuts&#39;</span>];

<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">groceries</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#e6db74">&#39;banana&#39;</span>)) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;We have to buy bananas!&#39;</span>);
} <span style="color:#66d9ef">else</span> {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;We don&#39;t have to buy bananas!&#34;</span>);
}
</code></pre></div><ul>
<li>A: We have to buy bananas!</li>
<li>B: We don&rsquo;t have to buy bananas</li>
<li>C: undefined</li>
<li>D: 1</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
我们传递了一个状态 groceries.indexOf(&ldquo;banana&rdquo;) 给 if 条件语句。groceries.indexOf(&ldquo;banana&rdquo;) 返回 0， 一个 falsy 的值。因为 if 条件语句的状态为 falsy，else 块区内的代码执行，并且 We don&rsquo;t have to buy bananas! 被输出.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>121.输出是什么？ 2021-05-10</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">config</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">languages</span><span style="color:#f92672">:</span> [],
  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">language</span>(<span style="color:#a6e22e">lang</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">languages</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">lang</span>);
  },
};
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">language</span>);
</code></pre></div><ul>
<li>A: function language(lang) { this.languages.push(lang }</li>
<li>B: 0</li>
<li>C: []</li>
<li>D: undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
方法 language 是一个 setter。Setters 并不保存一个实际值，它们的使命在于 修改 属性。当调用方法 setter， 返回 undefined。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>122.输出是什么？ 2021-05-11</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Wann Tonn&#39;</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#f92672">!</span><span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;object&#39;</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#f92672">!</span><span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>);
</code></pre></div><ul>
<li>A: false true</li>
<li>B: true false</li>
<li>C: false false</li>
<li>D: true true</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
typeof name 返回 &ldquo;string&rdquo;。字符串 &ldquo;string&rdquo; 是一个 truthy 的值，因此 !typeof name 返回一个布尔值 false。 false === &ldquo;object&rdquo; 和 false === &ldquo;string&rdquo; 都返回 false。</p>
<p>（如果我们想检测一个值的类型，我们应该用 !== 而不是 !typeof）</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>123.输出是什么？ 2021-05-11</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">add</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span>) =&gt; (<span style="color:#a6e22e">y</span>) =&gt; (<span style="color:#a6e22e">z</span>) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>);
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">z</span>;
};
<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">4</span>)(<span style="color:#ae81ff">5</span>)(<span style="color:#ae81ff">6</span>);
</code></pre></div><ul>
<li>A: 4 5 6</li>
<li>B: 6 5 4</li>
<li>C: 4 function function</li>
<li>D: undefined undefined 6</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
函数 add 是一个返回 返回箭头函数的箭头函数 的箭头函数（still with me?）。第一个函数接收一个值为 4 的参数 x。我们调用第二个函数，它接收一个值为 5 的参数 y。然后我们调用第三个函数，它接收一个值为 6 的参数 z。当我们尝试在最后一个箭头函数中获取 x, y 和 z 的值，JS 引擎根据作用域链去找 x 和 y 的值。得到 4 5 6.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>124.输出是什么？ 2021-05-11</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">range</span>(<span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span>) {
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">start</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">end</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">yield</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">i</span>);
  }
}
(<span style="color:#66d9ef">async</span> () =&gt; {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">gen</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">range</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>);
  <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">await</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">gen</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>);
  }
})();
</code></pre></div><ul>
<li>A: Promise {1} Promise {2} Promise {3}</li>
<li>B: Promise {&lt; pending &gt;} Promise {&lt; pending &gt;} Promise {&lt; pending &gt;}</li>
<li>C: 1 2 3</li>
<li>D: undefined undefined undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
我们给 函数 range 传递： Promise{1}, Promise{2}, Promise{3}，Generator 函数 range 返回一个全是 async object promise 数组。我们将 async object 赋值给变量 gen，之后我们使用 for await &hellip; of 进行循环遍历。我们将返回的 Promise 实例赋值给 item： 第一个返回 Promise{1}， 第二个返回 Promise{2}，之后是 Promise{3}。因为我们正 awaiting item 的值，resolved 状态的 promsie，promise 数组的 resolved 值 以此为： 1，2，3.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>125.输出是什么？ 2021-05-12</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myFunc</span> <span style="color:#f92672">=</span> ({<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>}) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)
})
</code></pre></div><ul>
<li>A: 1, 2, 3</li>
<li>B: {1: 1} {2: 2} {3: 3}</li>
<li>C: { 1: undefined } undefined undefined</li>
<li>D: undefined undefined undefined</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
myFunc 期望接收一个包含 x, y 和 z 属性的对象作为它的参数。因为我们仅仅传递三个单独的数字值 (1, 2, 3) 而不是一个含有 x, y 和 z 属性的对象 ({x: 1, y: 2, z: 3})， x, y 和 z 有着各自的默认值 undefined.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>126.输出是什么？ 2021-05-12</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getFine</span>(<span style="color:#a6e22e">speed</span>, <span style="color:#a6e22e">amount</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">formattedSpeed</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Intl</span>.<span style="color:#a6e22e">NumberFormat</span>({
    <span style="color:#e6db74">&#39;en-US&#39;</span>,
    {<span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;unit&#39;</span>, <span style="color:#a6e22e">unit</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;mile-per-hour&#39;</span>}
  }).<span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">speed</span>)

  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">formattedAmount</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Intl</span>.<span style="color:#a6e22e">NumberFormat</span>({
    <span style="color:#e6db74">&#39;en-US&#39;</span>,
    {<span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;currency&#39;</span>, <span style="color:#a6e22e">currency</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;USD&#39;</span>}
  }).<span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">amount</span>)

  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`The driver drove </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">formattedSpeed</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> and has to pay </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">formattedAmount</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>
}
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getFine</span>(<span style="color:#ae81ff">130</span>, <span style="color:#ae81ff">300</span>))
</code></pre></div><ul>
<li>A: The driver drove 130 and has to pay 300</li>
<li>B: The driver drove 130 mph and has to pay $300.00</li>
<li>C: The driver drove undefined and has to pay undefined</li>
<li>D: The driver drove 130.00 and has to pay 300.00</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
通过方法 Intl.NumberFormat，我们可以格式化任意区域的数字值。我们对数字值 130 进行 mile-per-hour 作为 unit 的 en-US 区域 格式化，结果为 130 mph。对数字值 300 进行 USD 作为 currentcy 的 en-US 区域格式化，结果为 $300.00.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>127.输出是什么？ 2021-05-12</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">spookyItems</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;👻&#39;</span>, <span style="color:#e6db74">&#39;🎃&#39;</span>, <span style="color:#e6db74">&#39;🕸&#39;</span>];
({ <span style="color:#a6e22e">item</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">spookyItems</span>[<span style="color:#ae81ff">3</span>] } <span style="color:#f92672">=</span> { <span style="color:#a6e22e">item</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;💀&#39;</span> });

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">spookyItems</span>);
</code></pre></div><ul>
<li>A: [&ldquo;👻&rdquo;, &ldquo;🎃&rdquo;, &ldquo;🕸&rdquo;]</li>
<li>B: [&ldquo;👻&rdquo;, &ldquo;🎃&rdquo;, &ldquo;🕸&rdquo;, &ldquo;💀&rdquo;]</li>
<li>C: [&ldquo;👻&rdquo;, &ldquo;🎃&rdquo;, &ldquo;🕸&rdquo;, { item: &ldquo;💀&rdquo; }]</li>
<li>D: [&ldquo;👻&rdquo;, &ldquo;🎃&rdquo;, &ldquo;🕸&rdquo;, &ldquo;[object Object]&quot;]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
通过解构对象们，我们可以从右手边的对象中拆出值，并且将拆出的值分配给左手边对象同名的属性。在这种情况下，我们将值 &ldquo;💀&rdquo; 分配给 spookyItems[3]。相当于我们正在篡改数组 spookyItems，我们给它添加了值 &ldquo;💀&rdquo;。当输出 spookyItems 时，结果为 [&ldquo;👻&rdquo;, &ldquo;🎃&rdquo;, &ldquo;🕸&rdquo;, &ldquo;💀&rdquo;]。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>128.输出是什么？ 2021-05-13</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Wann Tonn&#39;</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">27</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Number.isNaN(<span style="color:#a6e22e">name</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Number.isNaN(<span style="color:#a6e22e">age</span>));

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(isNaN(<span style="color:#a6e22e">name</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(isNaN(<span style="color:#a6e22e">age</span>));
</code></pre></div><ul>
<li>A: true false true false</li>
<li>B: true false false false</li>
<li>C: false false true false</li>
<li>D: false true false true</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
通过方法 Number.isNaN，你可以检测你传递的值是否为 数字值 并且是否等价于 NaN。name 不是一个数字值，因此 Number.isNaN(name) 返回 false。age 是一个数字值，但它不等价于 NaN，因此 Number.isNaN(age) 返回 false.</p>
<p>通过方法 isNaN， 你可以检测你传递的值是否一个 number。name 不是一个 number，因此 isNaN(name) 返回 true. age 是一个 number 因此 isNaN(age) 返回 false.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>129.输出是什么？ 2021-05-13</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">randomValue</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">22</span>;

<span style="color:#a6e22e">fucntion</span> <span style="color:#a6e22e">getInfo</span>() {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">randomValue</span>);
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">randomValue</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Wann Tonn&#34;</span>;
}

<span style="color:#a6e22e">getInfo</span>();
</code></pre></div><ul>
<li>A: &ldquo;number&rdquo;</li>
<li>B: &ldquo;string&rdquo;</li>
<li>C: undefined</li>
<li>D: ReferenceError</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
通过 const 关键字声明的变量在被初始化之前不可被引用：这被称之为 暂时性死区。在函数 getInfo 中, 变量 randomValue 声明在 getInfo 的作用域的此法环境中。在想要对 typeof randomValue 进行 log 之前，变量 randomValue 仍未被初始化： 错误 ReferenceError 被抛出! JS 引擎并不会根据作用域链网上寻找该变量，因为我们已经在 getInfo 函数中声明了 randomValue 变量。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>130.输出是什么？ 2021-05-13</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myPromise</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;Woah some cool data&#39;</span>);

(<span style="color:#66d9ef">async</span> () =&gt; {
  <span style="color:#66d9ef">try</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">myPromise</span>);
  } <span style="color:#66d9ef">catch</span> {
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">`Oops didn&#39;t work`</span>);
  } <span style="color:#66d9ef">finally</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;finally&#39;</span>);
  }
})();
</code></pre></div><ul>
<li>A: Woah some cool data</li>
<li>B: finally!</li>
<li>C: Woah some cool data finally!</li>
<li>D: Oops didn&rsquo;t work finally!</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
在 try 块区，我们打印 myPromise 变量的 awaited 值： &ldquo;Woah some cool data&rdquo;。因为 try 块区没有错误抛出，catch 块区的代码并不执行。finally 块区的代码 总是 执行，&ldquo;Oh finally!&rdquo; 被输出。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>131.输出是什么？ 2021-05-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">emojis</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;🥑&#34;</span>, [<span style="color:#e6db74">&#34;✨&#34;</span>, <span style="color:#e6db74">&#34;✨&#34;</span>, [<span style="color:#e6db74">&#34;🍕&#34;</span>, <span style="color:#e6db74">&#34;🍕&#34;</span>]]];

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">emojis</span>.<span style="color:#a6e22e">flat</span>(<span style="color:#ae81ff">1</span>));
</code></pre></div><ul>
<li>A: [&lsquo;🥑&rsquo;, [&lsquo;✨&rsquo;, &lsquo;✨&rsquo;, [&lsquo;🍕&rsquo;, &lsquo;🍕&rsquo;]]]</li>
<li>B: [&lsquo;🥑&rsquo;, &lsquo;✨&rsquo;, &lsquo;✨&rsquo;, [&lsquo;🍕&rsquo;, &lsquo;🍕&rsquo;]]</li>
<li>C: [&lsquo;🥑&rsquo;, [&lsquo;✨&rsquo;, &lsquo;✨&rsquo;, &lsquo;🍕&rsquo;, &lsquo;🍕&rsquo;]]</li>
<li>D: [&lsquo;🥑&rsquo;, &lsquo;✨&rsquo;, &lsquo;✨&rsquo;, &lsquo;🍕&rsquo;, &lsquo;🍕&rsquo;]</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
通过方法 flat， 我们可以创建一个新的, 已被扁平化的数组。被扁平化的深度取决于我们传递的值。在这个case里，我们传递了值 1 (并不必要，这是默认值)，相当于只有第一层的数组才会被连接。即这个 case 里的 [&lsquo;🥑&rsquo;] and [&lsquo;✨&rsquo;, &lsquo;✨&rsquo;, [&lsquo;🍕&rsquo;, &lsquo;🍕&rsquo;]]。连接这两个数组得到结果 [&lsquo;🥑&rsquo;, &lsquo;✨&rsquo;, &lsquo;✨&rsquo;, [&lsquo;🍕&rsquo;, &lsquo;🍕&rsquo;]].</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>132.输出是什么？ 2021-05-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> {
  <span style="color:#a6e22e">constructor</span>() {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  }
  <span style="color:#a6e22e">increment</span>() {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>;
  }
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counterOne</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Counter</span>();
<span style="color:#a6e22e">counterOne</span>.<span style="color:#a6e22e">increment</span>();
<span style="color:#a6e22e">counterOne</span>.<span style="color:#a6e22e">increment</span>();

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counterTwo</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">counterOne</span>;
<span style="color:#a6e22e">counterTwo</span>.<span style="color:#a6e22e">increment</span>();

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">counterOne</span>.<span style="color:#a6e22e">count</span>);
</code></pre></div><ul>
<li>A: 0</li>
<li>B: 1</li>
<li>C: 2</li>
<li>D: 3</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: B
<!-- raw HTML omitted -->
counterOne 是类 Counter 的一个实例，类Counter包含一个count 属性在它的构造函数里， 和一个increment方法。首先，我们通过counterOne.increment() 调用方法increment两次。现在，counterOne.count 为2.
然后，我们创建一个新的变量counterTwo 并将counterOne的引用地址赋值给它。因为对象受引用地址的影响，我们刚刚创建了一个新的对象，其引用地址和counterOne的等价。因此它们指向同一块内存地址，任何对其的副作用都会影响counterTwo。现在counterTwo.count 为2.
我们调用counterTwo.increment() 将count的值设为3.然后，我们打印counterOne里的count，结果为3.</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>133.输出是什么？ 2021-05-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myPromise</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">resolve</span>(Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Promise!&#34;</span>));

<span style="color:#a6e22e">fucntion</span> <span style="color:#a6e22e">funcOne</span>() {
  <span style="color:#a6e22e">myPromise</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">res</span> =&gt; <span style="color:#a6e22e">res</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">res</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>));
  <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Timeout!&#34;</span>), <span style="color:#ae81ff">0</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Last line!&#34;</span>);
}
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">funcTwo</span>() {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">myPromise</span>;
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">res</span>);
  <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Timeout!&#34;</span>), <span style="color:#ae81ff">0</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Last line!&#34;</span>);
}

<span style="color:#a6e22e">funcOne</span>();
<span style="color:#a6e22e">funcTwo</span>();
</code></pre></div><ul>
<li>A: Promise! Last line! Promise! Last line! Last line! Promise!</li>
<li>B: Last line! Timeout! Promise! Last line! Timeout! Promise!</li>
<li>C: Promise! Last line! Last line! Promise! Timeout! Timeout!</li>
<li>D: Last line! Promise! Promise! Last line! Timeout! Timeout!</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: D
<!-- raw HTML omitted -->
首先，我们调用 funcOne。在函数 funcOne 的第一行，我们调用myPromise promise 异步操作。当JS引擎在忙于执行 promise，它继续执行函数 funcOne。下一行 异步操作 setTimeout，其回调函数被 Web API 调用。 (详情请参考我关于event loop的文章.)</p>
<p>promise 和 timeout 都是异步操作，函数继续执行当JS引擎忙于执行promise 和 处理 setTimeout 的回调。相当于 Last line! 首先被输出， 因为它不是异步操作。执行完 funcOne 的最后一行，promise 状态转变为 resolved，Promise! 被打印。然而，因为我们调用了 funcTwo(), 调用栈不为空，setTimeout 的回调仍不能入栈。</p>
<p>我们现在处于 funcTwo，先 awaiting myPromise。通过 await 关键字， 我们暂停了函数的执行直到 promise 状态变为 resolved (或 rejected)。然后，我们输出 res 的 awaited 值（因为 promise 本身返回一个 promise）。 接着输出 Promise!。</p>
<p>下一行就是 异步操作 setTimeout，其回调函数被 Web API 调用。</p>
<p>我们执行到函数 funcTwo 的最后一行，输出 Last line!。现在，因为 funcTwo 出栈，调用栈为空。在事件队列中等待的回调函数（() =&gt; console.log(&ldquo;Timeout!&quot;) from funcOne, and () =&gt; console.log(&ldquo;Timeout!&quot;) from funcTwo）以此入栈。第一个回调输出 Timeout!，并出栈。然后，第二个回调输出 Timeout!，并出栈。得到结果 Last line! Promise! Promise! Last line! Timeout! Timeout!</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>134.我们怎样才能在 index.js 中调用 sum.js? 中的 sum？ 2021-06-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// sum.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">x</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span>;
}
<span style="color:#75715e">// index.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">sum</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;./sum&#34;</span>;
</code></pre></div><ul>
<li>A: sum(4)</li>
<li>B: sum.sum(4)</li>
<li>C: sum.default(4)</li>
<li>D: 默认导出不用 * 来导入，只能具名导出</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
使用符号 * ，我们引入 文件中的所有值，包括默认和具名。我们可以通过调用 sum.default 来调用该函数。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>135.输出什么？ 2021-06-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">set</span><span style="color:#f92672">:</span> () =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Added a new property!&#34;</span>),
  <span style="color:#a6e22e">get</span><span style="color:#f92672">:</span> () =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Accessed a property!)
</span><span style="color:#e6db74">};
</span><span style="color:#e6db74">const person = new Proxy({}, handler);
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">person.name = &#34;</span><span style="color:#a6e22e">Lydia</span><span style="color:#960050;background-color:#1e0010">&#34;</span>;
<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">name</span>;
</code></pre></div><ul>
<li>A: Added a new property!</li>
<li>B: Accessed a property!</li>
<li>C: Added a new property! Accessed a property!</li>
<li>D: 没有任何输出</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: C
<!-- raw HTML omitted -->
使用Proxy对象，我们可以给一个对象添加自定义行为。在这个case，我们传递一个包含以下属性的对象 handler: set and get。 每当我们设置属性值时 set 被调用，每当我们获取时 get 被调用。
第一个参数是一个空对象{},作为person的值。对于这个对象，自定义行为被定义在对象handler。如果我们向对象person添加属性，set将被调用。如果我们获取person的属性，get将被调用。
首先，我们向proxy对象{person.name = &ldquo;Lydia&rdquo;} 添加一个属性name。 set 被调用并输出 &ldquo;Added a new property&rdquo;。
然后，我们获取proxy对象的一个属性，对象handler的属性get 被调用。输出&quot;Accessed a property&rdquo;。</p>
<!-- raw HTML omitted -->
<hr>
<blockquote>
<p>134.以下哪一项会对对象 person 有副作用？ 2021-06-14</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Wann Tonn&#34;</span>};
Object.<span style="color:#a6e22e">seal</span>(<span style="color:#a6e22e">person</span>);
</code></pre></div><ul>
<li>A: person.name = &ldquo;WannTonn_1&rdquo;</li>
<li>B: person.age = 21</li>
<li>C: delete person.name</li>
<li>D: Object.assign(person, { age: 21 })</li>
</ul>
<!-- raw HTML omitted -->
<p>答案: A
<!-- raw HTML omitted -->
使用Object.seal 我们可以防止新属性 被添加，或者存在属性被移除。
然而，你仍然可以怼存在属性进行更改。</p>
<!-- raw HTML omitted -->
<hr>

    </div>
</article>




            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#摘录自-a-hrefhttpsgithubcomlydiahalliejavascript-questionsblobmasterzh-cnreadme-zh_cnmd-target_blankgithuba同步更新中">摘录自 <!-- raw HTML omitted -->Github<!-- raw HTML omitted -->。同步更新中。</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
        </div>
    </div>
    
    
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2021
                <a href="https://wanntonn.github.io/"></a>
                
                | Powered by <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>



</body>

</html>
