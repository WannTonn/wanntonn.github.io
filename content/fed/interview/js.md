---
title: '前端学习路线 - Javascript'
date: 2023-02-17T23:35:24+08:00
draft: true
tags:
 - Code
image: '/images/Code/javascript.png'
---
<!--more-->
- 执行上下文
  - 什么是执行上下文（context）
    - 是评估和执行JavaScript代码环境的抽象概念，每当JavaScript代码运行的时候，它都是在执行上下文中运行
  - 执行上下文的类型
    - 全局执行上下文
      - 默认或是基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：1.创建一个全局的window对象（浏览器环境下），并设置this的值等于这个全局对象，一个程序中只会有一个全局执行上下文
    - 函数执行上下文
      - 每当一个函数被调用时，都会为该函数创建一个新的上下文，每个函数都有他自己的执行上下文，不过是在函数被调用的时候创建的，函数上下文可以有任意个，每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤
    - Eval函数执行上下文
      - 执行在eval函数内的代码也会有属于他自己的执行上下文。
  - 执行栈（一种拥有LIFO<后进先出>数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当JavaScript引擎第一次运行该脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行那些执行上下文栈顶的函数。当该函数执行结束时，执行上下文会从栈中弹出，控制流程达到前栈中的下一个上下文。）
  -创建执行上下文
    - 创建阶段
      - this值的决定（this绑定）
        - 全局执行上下文：指向的是全局对象（浏览器中是指的window对象）
        - 函数执行上下文：this指向的值取决于该函数是如何被调用的，若被引用对象调用，那么this会被设置成那个对象，否则this的值会被设置为全局对象或者undefined（严格模式下）
      - 创建语法环境组件
        - 概念（词法环境是一种规范类型，基于ECMAScript代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境和空值组成）
        - 环境记录器（是存储变量和函数声明的实际位置）
        - 外部环境的引用（意味着它可以访问其父级词法环境（作用域））
        - 类型
          - 全局环境（在全局执行上下文中，是没有外部环境引用的词法环境。全局环境的外部环境引用是null。它拥有内建的Object/Array等。在环境记录器内的原型函数（关联全局对象，比如window对象）还有任何用户定义的全局变量，并且this的值指向全局对象）
          - 函数环境（在函数环境中，函数内部用户定义的变量存储在环境记录器重。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数）
      - 创建变量环境组件
    - 执行阶段
      - 变量赋值
      - 函数引用
      - 执行其他代码

- JavaScript的作用域链
  - 作用域
    - 概念（作用域是一个独立的域，让变量不会外泄，对外暴露。也就是说作用域最大的作用是隔离变量，不同作用域下同名变量不会有冲突）
    - 分类
      - 函数作用域（只能在函数内部才能访问的变量，也可以利用闭包来实现跨区域访问局部作用域的变量）
      - 块级作用域（ES6新增，用let/const 命令定义块级作用域的变量，外层作用域无法获取到内层作用域，即使外层和内层都使用同名变量名，也不会被干扰）
  - 作用域链（当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条））
- JavaScript的闭包
  - 概念（闭包是指有权访问另一个函数作用域中的变量和函数。创建闭包的方式就是在一个函数内部创建另一个函数）
  - 引用场景（存在的意义）（放置那些声明函数的词法环境里，被标记了进入环境，没有标记离开环境的变量（没有被回收的变量）供函数使用）
- this/call/apply/bind
  - this（this对象是在运行时基于函数的执行环境绑定的）
    - 全局函数执行上下文 （this指向window）
    - 函数执行上下文
      - 直接调用：this指向函数对象
      - call，apply：this指向绑定的对象上
      - bind：this将永久地被绑定到了bind的第一个参数
    - 匿名函数（因匿名函数执行环境具有全局性，因此this通常指window）
    - 箭头函数（所有的箭头函数没有自己的this，都指向外层）
    - new绑定（当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后油将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象：p1）
  - 改变this的指向 - apply、call、bind、箭头函数、new绑定
  - call和apply的区别
    - call
      - 语法（fn.call(thisArg,arg1,arg2,...)）
      - 概念（call()方法使用一个指定的this值和单独给出的一个或多个参数来调用一个函数）
      - 参数
        - thisArg(this指向，第一个参数)
          - 不传/null/undefined，函数中的this指向window对象
          - 传递另一个函数的函数名，函数中的this指向这个函数的引用，并不一定是该函数执行时真正的this值
          - 值为原始值（数字，字符串，布尔值）的this会指向该原始值的自动包装对象，如String，Number，Boolean
          - 传递一个对象，函数中的this指向这个对象
        - arg1，arg2...（指定的参数列表）
      - 返回值（使用调用者提供的this值和参数调用该函数的返回值。若该方法没有返回值，则返回undefined）
    - apply
      - 语法（fn.apply(thisArg, args[])）
      - 概念（apply()方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数）
      - 参数
        - thisArg（同call）
        - args（一个数组或类数组对象，其中的数组元素将作为单独的参数传给fn函数，如果该参数的值为null或undefined，则表示不需要传入任何参数。从ECMAScript5开始可以使用类数组对象）
      - 返回值（调用有指定this值和参数的函数的结果）
    - 区别 （第二个参数不同）
  - bind
    - 语法（fn.bind(thisArg[,arg1[,arg2[,...]]])）
    - 概念（bind()方法创建一个新的函数，在bind()被调用时，这个新函数被指定为bind()的第一个参数，而其余参数作为新函数的参数，供调用时使用）
    - 参数
      - thisArg（调用绑定函数作为this参数传递给目标函数的值。如果使用new运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转换为Object。如果bind函数的参数列表为空，或者thisArg是null/undefined，执行作用域的this将被视为新函数的thisArg）
      - arg1[,arg2[,...]]（当目标函数被调用时，被预置入绑定函数的参数列表中的参数）
    - 返回值（返回一个原函数的拷贝，并拥有指定的this值和初始参数）
- 原型/继承
  - JavaScript的原型
    - prototype(在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象，每一个JavaScript对象（除了null）创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性)
    - __proto__(每一个JavaScript对象（除了null）都具有一个属性，这个属性会指向该对象的原型)
  - JavaScript的原型链（每个对象都可以有一个原型__proto__，这个原型 还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找。如果没有的话就去它的原型对象里面去找，如果还是没有的话 再去原型对象的原型对象里面去寻找。这个操作被委托在整个原型链上，这个就是所谓的原型链了。）
  - 实现继承的几种方式（原型对象prototype的任何属性和方法都被传递，给那个类的所有实例，故可以利用这种功能实现继承机制）
    - ```javascript
      function Parent(name) {
        this.name = name;
      }
      Parent.prototype.sayName = function() {
        console.log(this.name);
      }
      function Child(name) {
        // 利用原型的特性实现继承
        Parent.call(name);
      }
      Child.prototype = new Parent();
      var child = new Child('child');
      child.sayName(); // 输出 child
      ```

- 深/浅拷贝
  - 基本数据类型（简单的数据段 保存在栈中，保存在内存中的一个位置。基本类型有：String, Number, Undefined, Null, Symbol, Boolean）
  - 引用数据类型（保存在堆内存中的对象，所以引用类型的值保存的是一个指针，这个指针指向存储在堆中的对象。除了上述6种基本类型。剩下的就是引用类型。统称为Object类型。分别有：Object，Array，Date，RegExp，Function等）